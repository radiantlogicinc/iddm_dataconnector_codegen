Directory structure:
└── radiantlogicinc-iddm-sdk/
    ├── README.md
    ├── LICENSE.txt
    ├── NOTICE.txt
    ├── pom.xml
    ├── README.txt
    ├── .gitlab-ci.yml
    ├── hooks/
    │   └── pre-commit
    ├── iddm-sdk-custom-connector/
    │   ├── README.md
    │   ├── pom.xml
    │   └── src/
    │       ├── main/
    │       │   ├── java/
    │       │   │   └── local/
    │       │   │       └── keycloak/
    │       │   │           ├── CompoundRequest.java
    │       │   │           ├── HttpStatus.java
    │       │   │           ├── KeycloakClient.java
    │       │   │           ├── KeycloakConnector.java
    │       │   │           ├── LdapToRestConverter.java
    │       │   │           ├── ResponseConverter.java
    │       │   │           └── SimpleRequest.java
    │       │   └── resources/
    │       │       └── local/
    │       │           └── keycloak/
    │       │               └── keycloak.json
    │       └── test/
    │           ├── java/
    │           │   └── local/
    │           │       └── keycloak/
    │           │           ├── KeycloakClientTest.java
    │           │           ├── KeycloakConnectorTest.java
    │           │           ├── KeycloakIntegrationTests.java
    │           │           ├── LdapToRestConverterTest.java
    │           │           ├── LoadKeycloakSampleData.java
    │           │           ├── ResponseConverterTest.java
    │           │           └── TestData.java
    │           └── resources/
    │               ├── groups.json
    │               ├── membership.json
    │               └── users.json
    ├── iddm-sdk-hello-world-connector/
    │   ├── pom.xml
    │   └── src/
    │       └── main/
    │           ├── java/
    │           │   └── local/
    │           │       └── demo/
    │           │           └── HelloWorldConnector.java
    │           └── resources/
    │               ├── data.json
    │               └── local/
    │                   └── demo/
    │                       └── hello_world.json
    ├── iddm-sdk-tutorial/
    │   ├── README.md
    │   ├── PennAveIAMDatasource.zip
    │   ├── pom.xml
    │   └── src/
    │       └── main/
    │           ├── java/
    │           │   └── local/
    │           │       └── demo/
    │           │           └── PennAveClient.java
    │           └── resources/
    │               ├── sample_data.json
    │               └── local/
    │                   └── demo/
    │                       └── pennave_connector.json
    └── src/
        ├── main/
        │   └── java/
        │       └── com/
        │           └── radiantlogic/
        │               └── iddm/
        │                   ├── DN.java
        │                   ├── lombok.config
        │                   ├── Modification.java
        │                   ├── RDN.java
        │                   ├── ResponseEntity.java
        │                   ├── SearchFilter.java
        │                   ├── ValidationUtils.java
        │                   ├── annotations/
        │                   │   ├── CustomConnector.java
        │                   │   ├── ManagedComponent.java
        │                   │   └── Property.java
        │                   ├── base/
        │                   │   ├── AuthenticationOperations.java
        │                   │   ├── AuthenticationRequest.java
        │                   │   ├── AuthenticationResponse.java
        │                   │   ├── ConnectionConfiguration.java
        │                   │   ├── ConnectionRequest.java
        │                   │   ├── ConnectionResponse.java
        │                   │   ├── Connector.java
        │                   │   ├── CreateOperations.java
        │                   │   ├── DeleteOperations.java
        │                   │   ├── ExtractSchemaOperations.java
        │                   │   ├── Field.java
        │                   │   ├── InjectableProperties.java
        │                   │   ├── LdapRequest.java
        │                   │   ├── LdapResponse.java
        │                   │   ├── LdapResultCode.java
        │                   │   ├── LdapSearchResponse.java
        │                   │   ├── Logger.java
        │                   │   ├── ModifyOperations.java
        │                   │   ├── NamingContextProperties.java
        │                   │   ├── OperationType.java
        │                   │   ├── ReadOnlyProperties.java
        │                   │   ├── ReadOperations.java
        │                   │   ├── Request.java
        │                   │   ├── Response.java
        │                   │   ├── ResponseStatus.java
        │                   │   ├── Schema.java
        │                   │   ├── SchemaObject.java
        │                   │   ├── SearchResultEntry.java
        │                   │   ├── SearchScope.java
        │                   │   ├── StatusCode.java
        │                   │   ├── TestConnectionOperations.java
        │                   │   ├── TestConnectionRequest.java
        │                   │   ├── TestConnectionResponse.java
        │                   │   ├── TypeConverter.java
        │                   │   ├── TypePair.java
        │                   │   ├── TypeTokenFactory.java
        │                   │   └── Uri.java
        │                   ├── exceptions/
        │                   │   ├── PluginConfigurationException.java
        │                   │   ├── PluginException.java
        │                   │   ├── PluginLoadingException.java
        │                   │   ├── PluginLoadingRuntimeException.java
        │                   │   ├── PluginOperationNotSupportedException.java
        │                   │   └── PluginRuntimeException.java
        │                   ├── ldap/
        │                   │   ├── AddRequest.java
        │                   │   ├── BindRequest.java
        │                   │   ├── DeleteRequest.java
        │                   │   ├── ModifyRequest.java
        │                   │   └── SearchRequest.java
        │                   └── test/
        │                       └── TestLogger.java
        └── test/
            └── java/
                └── com/
                    └── radiantlogic/
                        └── iddm/
                            ├── DNTest.java
                            ├── SearchFilterTest.java
                            ├── ValidationUtilsTest.java
                            └── base/
                                ├── DemoConnector.java
                                ├── FieldTest.java
                                ├── SearchScopeTest.java
                                ├── TypeConverterTest.java
                                └── TypePairTest.java

================================================
FILE: README.md
================================================
# IDDM SDK

This library project contains the set of interfaces, classes, and supporting utilities needed to create, compile, and deploy any type of supported custom functional extension to Radiant Logic IDDM.

## :construction: Roadmap Status :construction:

This section will be removed when the project reaches a TBD full-featured release state.  Until then, update the task list below as the library is built out:

- [x] Estabish Gitlab Project
- [ ] Finalize [MVP Design Document](https://radiantlogic.sharepoint.com/:w:/r/sites/dev/Shared%20Documents/SDK/IDDM%20SDK%20Design%20-%20MVP.docx?d=wbd42e13d7e504e9f9da12b6bc6a2004d&csf=1&web=1&e=5J1185)
- [x] Move existing Custom Data Backend interfaces to SDK lib
- [x] Establish CI infrastructure & publish for internal maven usage
- [x] Refactor IDDM Backend to recognize and use SDK-based plugins
- [ ] Implement final agreed MVP spec from design document linked above
- [ ] MVP Release (labelling TBD; could be v0.x, beta, v1.0, etc)
- [ ] :construction: ADD CHECKLIST ITEMS FOR REMAINING POST-MVP WORK :construction:

## Usage

Only internal Radiant Logic dev team members should have access to this project.  Non-release builds will publish to internal maven repositories for usage in other internal projects.  Release builds will publish to a public maven repository (central).

3rd party SDK users do not need this project.  They just need to use the public output from Maven central.

## Dependency Rules

This SDK library is meant to be a stable, public tool that operates completely independently of IDDM.  Therefore the following code dependency rules are in place:

- No non-public code dependencies
- No SNAPSHOT code dependencies


================================================
FILE: LICENSE.txt
================================================



================================================
FILE: NOTICE.txt
================================================



================================================
FILE: pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <!-- Artifact Specification -->
  <name>Radiant Logic IDDM Connector SDK</name>
  <groupId>com.radiantlogic</groupId>
  <artifactId>iddm-sdk</artifactId>
  <version>${revision}</version>
  <!--    this was originally JAR until i set the parent pom for the connector -->
  <packaging>jar</packaging>

  <dependencies>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.36</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.17.0</version>
    </dependency>
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>33.3.1-jre</version>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.11.3</version>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-params</artifactId>
      <version>5.11.3</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.assertj</groupId>
      <artifactId>assertj-core</artifactId>
      <version>3.27.2</version>
      <scope>compile</scope>
    </dependency>


    <!-- ###################################################################### -->
    <!-- TEMPORARY DEPENDENCY FOR PROOF OF CONCEPT. THIS SHOULD BE REMOVED ASAP -->
    <!-- ###################################################################### -->
    <dependency>
      <groupId>com.unboundid</groupId>
      <artifactId>unboundid-ldapsdk</artifactId>
      <version>7.0.1</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-annotations</artifactId>
      <version>2.18.2</version>
      <scope>compile</scope>
    </dependency>

  </dependencies>

  <!--  Added to build a JAR with all dependencies. Used for testing locally with Gradle in ROS v7.4. -->
  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>2.3.1</version>
          <configuration>
            <source>1.8</source>
            <target>1.8</target>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
    <plugins>
      <!-- any other plugins -->
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
      <!-- Spotless plugin for code formatting -->
      <plugin>
        <groupId>com.diffplug.spotless</groupId>
        <artifactId>spotless-maven-plugin</artifactId>
        <version>2.30.0</version>
        <configuration>
          <java>
            <googleJavaFormat>
              <version>1.7</version>
            </googleJavaFormat>
          </java>
        </configuration>
      </plugin>
      <plugin>
        <groupId>com.rudikershaw.gitbuildhook</groupId>
        <artifactId>git-build-hook-maven-plugin</artifactId>
        <version>3.5.0</version>
        <configuration>
          <gitConfig>
            <core.hooksPath>hooks/</core.hooksPath>
          </gitConfig>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>configure</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>flatten-maven-plugin</artifactId>
        <version>1.2.7</version>
        <executions>
          <execution>
            <id>flatten</id>
            <phase>verify</phase>
            <goals>
              <goal>flatten</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <updatePomFile>true</updatePomFile>
        </configuration>
      </plugin>
    </plugins>
  </build>


	<!-- Config Values -->
    <properties>
        <revision>8.1.4-beta.2-SNAPSHOT</revision>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

</project>


================================================
FILE: README.txt
================================================



================================================
FILE: .gitlab-ci.yml
================================================
spec:
  inputs:
    release_version:
      description: The version number of the release, in semver format
      regex: ^\d+\.\d+\.\d+(-(alpha|beta|rc)\.\d+)?$
      type: string
      default: 0.0.0
    release_operation:
      description: >-
        The type of release operation to perform. 
        "full_release" performs a full release process for the release_version, 
        "snapshot_branch" only creates a release branch with the -SNAPSHOT variant of 
        the release_version
      type: string
      options:
        - full_release
        - snapshot_branch
      default: full_release
    integration_name:
      description: The unique, case-sensitive name to be assigned to all related integration builds.
      type: string
      default: ""
---
include:
  - project: radiant-logic-engineering/radiant-one-pipelines
    ref: v2
    file: 'pipelines/v8-libraries.yml'
    inputs:
      release_version: $[[ inputs.release_version ]]
      release_operation: $[[ inputs.release_operation ]]
      integration_name: $[[ inputs.integration_name ]]
  - project: radiant-logic-engineering/radiant-one-pipelines
    ref: v2
    file: 'pipelines/common/rules.yml'
    inputs:
      release_version: $[[ inputs.release_version ]]
      integration_name: $[[ inputs.integration_name ]]
  - project: radiant-logic-engineering/radiant-one-pipelines
    ref: v2
    file: 'pipelines/common/default-runner.yml'

variables:
  CI_JAVA_TAG: 8-maven3.9.6-gradle7.5

# Overriding and disabling this job
Run PMD:
  stage: Validate Project
  extends:
    - .maven_run_pmd
  rules:
    - if: '"true" == "false"'

# Overriding and disabling this job
Run Spotless:
  stage: Validate Project
  extends:
    - .maven_run_spotless
  rules:
    - if: '"true" == "false"'

# Overriding and disabling this job
Run Sonar:
  stage: Validate Project
  extends:
    - .maven_run_sonar
  rules:
    - if: '"true" == "false"'

Build RadiantOneSuite:
  stage: Finalize
  trigger:
    project: radiant-logic-engineering/radiant-one-suite
    strategy: depend
    inputs:
      release_version: $[[ inputs.release_version ]]
      release_operation: $[[ inputs.release_operation ]]
      integration_name: $[[ inputs.integration_name ]]
  rules:
    - !reference [ .run_for_main, rules ]


================================================
FILE: hooks/pre-commit
================================================
#!/bin/bash

set -euo pipefail

run() {
  echo "Running spotless pre-commit check..."

  IFS=$'\n'
  pre_format_files=($(git diff --name-only --staged))
  mvn spotless:apply

  for pre_file in "${pre_format_files[@]}"; do
    if [ -f "$pre_file" ]; then
      echo "Re-adding spotless formatted file: to git $pre_file"
      git add "$pre_file"
    fi
  done
}

run


================================================
FILE: iddm-sdk-custom-connector/README.md
================================================
## Introduction

This SDK provides IDDM users the materials to implement, validate, and deploy their own custom data connectors for IDDM.

Unlike previous IDDM/RadiantOne implementations, this SDK will be completely sufficient for developing and unit testing
custom data connectors.

## Core API Explained

The minimum requirements for implementing a custom connector are:

- Apply the `@CustomConnector` annotation to the custom connector class.
- Define a JSON file specifying details of how to display and configure the connector
- Implement at least one Java interface that specifies which LDAP operations the connector supports.

```java

@CustomConnector(metaJsonFile = "derbySqlConnector.json")
public class DerbySqlCustomConnector implements ReadOperations<SearchRequest> {
  /* ...provide connector implementation... */
}
```

The `@CustomConnector` annotation enables IDDM to identify the connector without requiring special naming conventions or
package structures. It also supports additional features discussed later.

The LDAP operation interfaces specify exactly which LDAP operations the connector supports:

- `ReadOperations<T extends Request>`
- `CreateOperations<T extends Request>`
- `ModifyOperations<T extends Request>`
- `DeleteOperations<T extends Request>`

Each interface (and connector) accepts an incoming request and returns a response. These are represented by `Request`
and `Response` interfaces respectively. The SDK includes `Request` implementations for common LDAP operations:

- `SearchRequest`
- `ModifyRequest`
- `AddRequest`
- `DeleteRequest`

When implementing an LDAP operation interface, the developer specifies the expected `Request` type by setting the type
parameter `T`. This tells IDDM to convert incoming requests to that type before sending them to the connector. Returning
to the previous example, this means `DerbySqlCustomConnector` supports read operations and expects incoming requests as
`SearchRequest` objects.

The LDAP operation interfaces return responses as `ResponseEntity<T>` objects. This class stores a result code and any
additional data needed to fulfill the request (e.g., search results). This eliminates the need to place results into the
`InterceptParam` argument currently used by connectors.

```java

@Override
public ResponseEntity<?> search(SearchRequest searchRequest) {
  // Do work to process the request, getting data from the backend
  List<Object> searchResults = getDataFromCustomDatasource(searchRequest);
  return new ResponseEntity<>(ResponseStatus.OK, searchResults);
} 
```

Non-trivial connectors require information from IDDM to operate. This might include details for connecting to a remote
host or a naming context's root DN.

Custom configuration settings specific to the connector are declared by the developer in their JSON resource file's
`meta` attribute. Attributes
defined here will be presented, accepted from the user, and validated by the IDDM UI.

The `name`, `description`, and `sectionName` control how each property will appear in IDDM. The specified
`defaultValue` will be populated on new datasources by default when they are using the connector. Entered
values will be validated by IDDM against the specified `dataType`, `isRequired`, and `regex`. Accepted
`dataType` values are `STRING`, `PASSWORD`, `BOOLEAN`, `NUMBER` and `LIST`. The IDDM UI will mask the
entry of properties with type `PASSWORD`.

The developer requests both basic IDDM data and connector specific configuration settings at runtime by applying the
`@Properties(name = <property_set_name>)` annotation to constructor arguments and specifying what information IDDM
should provide:

```java

@CustomConnector
public class DerbySqlCustomConnector implements ReadOperations<SearchRequest> {

  public DerbySqlCustomConnector(
      @Properties(name = SCHEMA) SchemaCollection schemas)
  )

  {
    /* ...do work... */
  }
}

```

The "property sets" available via `@Properties` will be specified in the public SDK documentation. These currently
include:

- `CONNECTION_CONFIGURATION` - provides details for connecting to the custom data source (references the connector
  specific properties defined in the connector JSON info).
- `SCHEMA` - provides schema(s) used by the naming context that is calling the custom connector.
- `NAMING_CONTEXT` - provides details about the naming context that is using the connector (e.g., DN, associated data
  sources).

Each property set is provided in an appropriate custom class (e.g., `SchemaCollection`, `ConnectionConfiguration`) to
make working with the properties easier and to remove dependence on `InterceptParam` and many existing utility classes:

```java
public class SqlConnectionConfiguration implements ConnectionConfiguration {

  public String getHostname() { /* ... */ }

  public String getUsername() { /* ... */ }

  public String getDatabase() { /* ... */ }

  public String connectionString() ()

  { /* ... */ }
  /* ...and so on... */
}
```

Additional property sets can and will be added as needed.

### JSON Connector Configuration

In addition to the connector code itself, a JSON file is required that describes the connector for purposes of
loading in IDDM. This file must describe some general information about the connector, for display purposes, and a set
of configuration properties that IDDM should prompt users to specify values for. An example of this is in the sample
connector implementation:
[Keycloak Connector JSON](src/main/java/local/keycloak/keycloak.json)

## Simple Custom Connector Example

Below is a near complete example of what a custom connector for communicating with an Apache Derby SQL database might
look like using the new SDK. The class uses the `@CustomConnector` annotation to identify itself as a connector. It
implements the `ReadOperations` interface to support LDAP searches. And it uses the `@Properties` annotation to request
schema and naming context information from IDDM.

Two things to note. A custom connector is not required for access SQL data sources, but SQL was selected for this
example because of readers' likely familiarity with it. Also, we do not necessarily recommend implementing an entire
connector in a single, large Java class. But we recognize this is how many customers' connectors are implemented, so we
take a similar approach, again, for readers' familiarity.

```java

/** Example custom SQL connector for performing searches. */
@CustomConnector(metaJsonFile = "derbySqlConnector.json")
public class DerbySqlCustomConnector implements ReadOperations<SearchRequest> {

  private final SqlConnectionConfiguration connectionConfiguration;

  private final NamingContextProperties namingContextProperties;

  /** Constructor used by IDDM to provide the requested property sets. */
  public DerbySqlCustomConnector(
      @Properties(name = CONNECTION_CONFIGURATION) SqlConnectionConfiguration connectionConfiguration,
      @Properties(name = NAMING_CONTEXT) NamingContextProperties namingContextProperties
  ) {
    this.connectionConfiguration = connectionConfiguration;
    this.namingContextProperties = namingContextProperties;
  }

  /** Entry point for custom connector when performing an LDAP search. */
  @Override
  public ResponseEntity<?> search(SearchRequest ldapRequest) {
    try {
      String sqlCommand = createSQLCommandFrom(ldapRequest);
      ResultSet sqlResponse = executeSQLCommand(sqlCommand);
      List<SearchResult> searchResults = createLdapResponseFrom(sqlResponse);
      return new ResponseEntity<>(ResponseStatus.OK, searchResults);
    } catch (SQLException ex) {
      return new ResponseEntity<>(ResponseStatus.FAILED, ex);
    }
  }

  private String createSQLCommandFrom(SearchRequest ldapRequest) {
    /* ...do work... */
  }

  private ResultSet executeSQLCommand(String sqlCommand) throws SQLException {

    // Open connection to the SQL server
    Connection connection = DriverManager.getConnection(
        connectionConfiguration.connectionString(),
        connectionConfiguration.getUsername(),
        connectionConfiguration.getPassword());

    // Execute the SQL command
    Statement statement = connection.createStatement();
    return statement.executeQuery(sqlCommand);
  }

  private List<SearchResult> createLdapResponseFrom(ResultSet sqlResponse) throws SQLException {

    List<SearchResult> searchResults = new ArrayList<>();
    ResultSetMetaData resultSetMetaData = sqlResponse.getMetaData();

    // Read each row returned by the SQL server into an LDAP SearchResult object
    while (sqlResponse.next()) {
      BasicAttributes entryAttributes = new BasicAttributes();
      for (int column = 1; column <= resultSetMetaData.getColumnCount(); column++) {
        String attributeName = resultSetMetaData.getColumnClassName(column);
        Object attributeValues = sqlResponse.getObject(column);
        attributes.put(attributeName, attributeValues);
      }
      searchResults.add(new SearchResult(namingContextProperties.getDN(), null, attributes));
    }

    return searchResults;
  }
}
```

## Additional API Features Explained

A common problem with many existing custom connectors is they are implemented as monolithic classes. This leads to
connector code that is more error-prone, difficult to understand and maintain, and nearly impossible to test without a
real IDDM and backend data source. Features in this section are introduced to help improve the developer experience by
encouraging code that is maintainable, bug-free, and reusable.

### `TypeConverter` Interface

The `TypeConverter<FROM,TO>` interface encourages isolating the work of converting between different request and
response types. Moving this logic helps break apart the monolithic connector class, and produces more focused
components (concerned with only converting types) that are easier to test and reuse.

`Request` and `Response` (introduced in the previous section) are marker interfaces. That is, they contain no methods or
fields. This allows developers to create custom request and response types that are more suitable for their connectors:

```java
/** Custom SQL SELECT request data type. */
public class SQLSelectRequest implements Request {

  private final List<String> expressions = new ArrayList();
  private final List<String> tables = new ArrayList();
  private final List<String> where = new ArrayList();

  public String build() {
    return this.select() + this.from() + this.where();
  }
```

Connectors then can be implemented to accept these custom request types by changing the LDAP operation interface type
arguments:

```java

@CustomConnector
public class DerbySqlCustomConnector implements ReadOperations<SQLSelectRequest> {
  /* ...class implementation... */
}
```

Recall that IDDM automatically converts incoming requests to whatever type is expected by the connector. But IDDM does
not natively know how to create the custom types from `LdapRequest` objects, so the developer must provide that logic.
This is done in two steps. First, by extending the `TypeConverter<FROM,TO>` abstract class, defined as:

```java
public abstract class TypeConverter<FROM, TO> {

  public abstract TO convert(FROM source);
}
```

Then by registering the `TypeConverter` implementation by adding it to the `@CustomConnector(typeConverters = {...})`
annotation. Returning to the earlier SQL example, an LDAP `SearchRequest` to `SQLSelectRequest` converter can be defined
as:

```java
public class LdapRequestAdapter extends TypeConverter<SearchRequest, SQLSelectRequest> {

  public SQLSelectRequest convert(SearchRequest request) {
    /* ...do the work of converting from a SearchRequest to a SQLSelectRequest... */
  }
}
```

Then registered for use:

```java

@CustomConnector(metaJsonFile = "derbySqlConnector.json", typeConverters = {LdapRequestAdapter.class})
public class DerbySqlCustomConnector implements Readable<SQLSelectRequest> {
  /* ...class implementation... */
}
```

Multiple type converters can be registered with a single connector, but each class-to-class mapping must be unique. The
developer never needs to directly call these converters. IDDM automatically identifies and applies the appropriate
converter before passing a request to the connector.

`TypeConverter`s can also be used for responses. This is most useful when returning search results. Recall that
connectors must return a `ResponseEntity` containing a result code and optional data (e.g., search results). The SDK
imposes no requirements on how that data is structured. But IDDM does because the data is eventually converted into LDAP
results containing entries' distinguished names and attributes. In the earlier SQL example, the
`List<SearchResult> createLdapResponseFrom(ResultSet sqlResponse)` method does this work, but a `TypeConverter` can be
used instead:

```java
public class ResultSetAdapter extends TypeConverter<ResultSet, List<SearchResult>> {

  @Override
  public List<?> convert(ResultSet sourceData) {
    /* ...do work of converting a ResultSet into a list of SearchResult objects... */
  }
}
```

The response converter is registered the same way as the request converter:

```java
@CustomConnector(typeConverters = {LdapRequestConverter.class, ResultSetConverter.class})
```

### `@ManagedComponent` Annotation

The `@ManagedComponent` annotation encourages clean coding practices and eases the use of test-double by adding some
limited support for constructor-based dependency injection. The annotation is applied to classes that IDDM should
automatically instantiate and inject. This will most often be classes that exist outside the SDK such as custom data
source clients.

To be eligible for annotation, the class must:

- Have only one constructor
- Have a no-arg constructor, _or_ all arguments must be either annotated with`@Properties` or types annotated with
  `@ManagedComponent`.

The example below annotates a `SqlClient` class as a managed component. The class has only one constructor and it
expects a `ConnectionConfiguration` (which is also a managed component):

```java

@ManagedComponent
public class SqlClient {

  private final ConnectionConfiguration connectionConfig;

  public SqlClient(final ConnectionConfiguration connectionConfig) {
    this.connectionConfig = connectionConfig;
  }
}
```

Now whenever IDDM encounters `SqlClient` as a constructor argument, IDDM will automatically create and pass-in a new
instance:

```java
public class DerbySqlCustomConnector implements ReadOperations<SQLSelectRequest> {

  /** IDDM creates then injects the SqlClient object. */
  public DerbySqlCustomConnector(SqlClient client) {
    this.sqlClient = client;
  }
```

### Logging

The SDK provides a `Logger` interface for logging messages from connectors and managed components. The logger is automatically injected when included as a constructor parameter in classes annotated with either `@CustomConnector` or `@ManagedComponent`. The injected logger implementation provides log4j-style message formatting.

Log messages written using this logger are stored in the IDDM `logs/connectors/` directory. Each log file is named after the data source that produced it.
Here's an example of using the logger in a custom connector:

```
@ManagedComponent
public class MyClass {
  private final Logger logger;
  
  public MyClass(Logger logger) {
    this.logger = logger;
  }

  public void sendRequest(String url) {
    try {
      logger.info("Sending request to {}", url);
    } catch (Exception e) {
      logger.error(e, "Problem occurred while sending request to {}", url);
    }
  }
}
```

For unit tests, use the special logger implementation: `TestLogger`. It simply prints all log messages to the output:

```
KeycloakConnector connector = new KeycloakConnector(client, responseConverter, new TestLogger());
```

To control the log level when the connector is used in IDDM, add the following custom property definition to the connector JSON config:

```
{ 
  "name": "loglevel", 
  "description": "Verbosity level of logging (ERROR, WARN, INFO, DEBUG, TRACE)", 
  "sectionName": "Logging", 
  "defaultValue": "INFO", 
  "dataType": "STRING", 
  "isRequired": false, 
  "regex": "^(?:\\d+|(?i)(ERROR|WARN|INFO|DEBUG|TRACE))$" 
}
```

This will add the log level setting to the custom datasource template.

## SDK Component Summary

These are descriptions of major components in the current SDK.

| Component                | Description                                                                                                                                                                                                                                                                                                                                                                                                 |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `@CustomConnector`       | An annotation applied to the primary connector class, and used by IDDM to identify the connector. The annotation accepts a required parameter identifying a relative resource path to a JSON file containing metadata about the connector.  It also accepts an optional parameter specifying custom `TypeConverter` classes for IDDM to use with the connector.                                             |
| `Connector`              | A marker interface for classes that define more concrete functionality for the connector. This should be treated as an internal class with developers instead using one of its subclasses such as `ReadOperations`.                                                                                                                                                                                         |
| `@Properties`            | An annotation applied when IDDM should inject configuration data (e.g., schemas or data source properties). The SDK contains a predefined list of named property sets that can be injected. The developer uses the annotation's `name` parameter to specify which property set to inject. The annotation can be applied to only constructor arguments in user defined classes.                              
| `Request`                | A marker interface for data types passed from IDDM to the connector. The SDK includes concrete implementation for different LDAP requests, but developers can directly implement the interface to create their own custom request types.                                                                                                                                                                    |
| `Response`               | A marker interface for data types returned from the connector to IDDM. The SDK includes the `ResponseEntity` implementation, but developers can directly implement the interface to create their own custom request types.                                                                                                                                                                                  |
| `TypeConverter<FROM,TO>` | An abstract class that can be extended to create `Request` and `Response` converters. Such converters are necessary when using custom `Request` or `Response` implementations. The converter is registered for use by the connector via the `@CustomConnector` annotation's `typeConverters` argument.                                                                                                      |
| `@ManagedComponent`      | An annotation applied to classes to make them eligible for automatic constructor-based injection. Annotated classes are automatically instantiated and injected by IDDM whenever they appear as constructor arguments. The annotated class must have only one constructor, and that constructor must either have no arguments or all arguments must be annotated with `@Properties` or `@ManagedComponent`. |

#### Connector Implementations

| `Connector`                           | Description                                                                                                     |
|---------------------------------------|-----------------------------------------------------------------------------------------------------------------|
| `ReadOperations<T extends Request>`   | An interface implemented by connectors that support read/search operations.                                     |
| `CreateOperations<T extends Request>` | An interface implemented by connectors that support create/add operations in the custom data source.            |
| `ModifyOperations<T extends Request>` | An interface implemented by connectors that support updating/modifying existing data in the custom data source. |
| `DeleteRequest<T extends Request>`    | An interface implemented by connectors that support deleting data from the custom data source.                  |

#### Request Implementations

| `Request`       | Description                                                                                                                                                                                                          |
|-----------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `LdapRequest`   | A marker interface for LDAP requests.                                                                                                                                                                                |
| `SearchRequest` | An implementation of `LdapRequest` that contains the information necessary to perform LDAP search operations. [RFC 4511 section 4.5.1](https://docs.ldap.com/specs/rfc4511.txt) defines the search request protocol. |
| `ModifyRequest` | An implementation of `LdapRequest` containing the information needed to perform an LDAP modify operation.  [RFC 4511 section 4.6](https://docs.ldap.com/specs/rfc4511.txt) defines the modify operation protocol.    |
| `AddRequest`    | An implementation of `LdapRequest` that contains the information needed to perform an LDAP add operation. [RFC 4511 section 4.7](https://docs.ldap.com/specs/rfc4511.txt) defines the add operation protocol.        |
| `DeleteRequest` | An implementation of `LdapRequest` that has the info needed to perform an LDAP delete operation. [RFC 4511 section 4.8](https://docs.ldap.com/specs/rfc4511.txt) defines the delete operation protocol.              |

#### Response Implementations

| `Response`       | Description                                                                                                                                                                             |
|------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `ResponseEntity` | A generic data structure for storing an operation result code and any additional data returned by the server.                                                                           |
| `LdapResponse`   | Container object for storing LDAP specific result codes (as defined in [RFC 4511 section 4.8](https://docs.ldap.com/specs/rfc4511.txt)) and any additional data returned by the server. |
|                  |                                                                                                                                                                                         |

#### Property Sets

| Name                       | Object                    | Description                                                                                                                                                                                                                                                                                                                                                                                             |
|----------------------------|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `CONNECTION_CONFIGURATION` | `ConnectionConfiguration` | Provides properties of the custom data source that is using the connector (e.g., properties seen on the _Edit Custom Data Source_ page in the IDDM Main Control Panel).                                                                                                                                                                                                                                 |
| `SCHEMA`                   | `SchemaCollection`        | Provides information about the type and structure of data stored in the custom data source. This class tries to avoid imposing or implying any semantic meaning on the data, leaving that task to the developer. For example, a `SchemaCollection` for a SQL data source is a collection of tables but a `SchemaCollection` for a CSV data source may describe different input files and their columns. |
| `NAMING_CONTEXT`           | `NamingContextProperties` | Provides basic properties about the naming context that is using the connector such as root DN.                                                                                                                                                                                                                                                                                                         |

#### Configuration JSON

##### Root object attributes

| Attribute             | Format    | Description                                                                                                                     |
|-----------------------|-----------|---------------------------------------------------------------------------------------------------------------------------------|
| `name`                | `string`  | Display name for the connector in IDDM                                                                                          |
| `description`         | `string`  | More detailed discription of the connector for display in IDDM                                                                  |
| `backendCategory`     | `string`  | Fixed value of "custom".  Will be overridden by IDDM regardless                                                                 |
| `userCreated`         | `boolean` | Fixed value of `true`.  Will be overridden by IDDM regardless                                                                   |
| `icon`                | `string`  | Path of an icon that should be displayed for the connector in IDDM                                                              |
| `isSchemaExtractable` | `boolean` | This property will go away, and is ignored for SDK connectors.  Indicate this instead by implementing `ExtractSchemaOperations` | 
| `meta`                | `array`   | List of meta attributes describing configuration settings. See the _Meta Attributes_ section for details.                       |

##### Meta Attributes

| Attribute      | Format  | Description                                                                                                   |
|----------------|---------|---------------------------------------------------------------------------------------------------------------|
| `name`         | string  | Name of the setting, as it will be searched for in the `CONNECTION_CONFIGURATION` by the connector            |
| `description`  | string  | A more detailed description of the setting for the user who is configuring the connector                      |
| `sectionName`  | string  | A section heading under which this setting should appear IDDM                                                 |
| `defaultValue` | string  | The value IDDM should apply to the setting if the user does not specify one.  Set to "" if no default needed. |
| `dataType`     | string  | One of:  "STRING", "PASSWORD", "BOOLEAN", "NUMBER", or "LIST"                                                 |
| `isRequired`   | boolean | `true` if IDDM should enforce that the user must enter a value for this property                              |
| `regex`        | string  | A regular expression for validating user-entered values of this property                                      |

## Building the Connector Jar

The connector jar may be compiled as you would any other Java application or library; at Radiant Logic this is typically
done with Maven as seen in the sample connector. There are only a few additional special considerations:

- Must be built for Java 8
- Include the specified JSON metadata resource file in the correct location within the jar. For example, if your
  annotation specifies "my_connector.json", then IDDM will look for a file named "my_connector.json" within the same
  package folder as the class file of the annotated connector class. The value specified to the annotation is a resource
  path relative to the class bearing the `@CustomConnector` annotation.
- Include all SDK-annotated classes, and any non-SDK-annoated class you've written that they depend upon
- Build your plugin as a "fat jar", which includes all of its 3rd party dependencies compiled in. This can be easily
  accomplished in maven by using the `maven-assembly-plugin`, and configuring it to build your jar as a
  `jar-with-dependencies`.

No specific package/class structure or content is required for a valid data connector plugin jar in IDDM other than the
details prescribed in this guide. With the proper interfaces and annotations in place, IDDM will examine the jar and
automatically determine which classes to use as well as how to use them.

#### Required/Suggested Tools

Plugins for IDDM must be runnable on **Java 8**, so you should build it with JDK 8 or configure your compiler to target
Java 8 at runtime. The sample project's [pom.xml](pom.xml) demonstrates a straightforward way to do this for Maven
builds:

```xml

<plugin>
  <groupId>org.apache.maven.plugins</groupId>
  <artifactId>maven-compiler-plugin</artifactId>
  <version>2.3.1</version>
  <configuration>
    <source>1.8</source>
    <target>1.8</target>
  </configuration>
</plugin>
```

The sample project's [pom.xml](pom.xml) also includes a simple way to build your output as a "fat jar" where
dependencies are bundled into the jar:

```xml

<plugin>
  <artifactId>maven-assembly-plugin</artifactId>
  <executions>
    <execution>
      <phase>package</phase>
      <goals>
        <goal>single</goal>
      </goals>
    </execution>
  </executions>
  <configuration>
    <descriptorRefs>
      <descriptorRef>jar-with-dependencies</descriptorRef>
    </descriptorRefs>
  </configuration>
</plugin>
```

While not explicitly required, **Maven 3** is strongly recommended as the tool of choice for compiling IDDM SDK plugins.
This will make the sample materials easy to directly adapt to your needs, and keep your build/deployment process simple
to execute. If using maven, and configuring everything as the sample project has, building your jar consists simply of
invoking `mvn package` on the command line or via your IDE of choice.

> *NOTE:*
>
> Currently Maven is recommended for developer convenience, but may become a stronger recommendation or even an outright
> requirement, pending final design after SDK beta.

## Sample Connector Project

A custom [Keycloak](https://www.keycloak.org/) sample connector is provided to demonstrate many of the connector
framework's core features. This includes classes, annotations, recommended class organization, unit testing, and loading
a connector into an IDDM instance.

The project is largely self-contained in that it does not depend on IDDM. All tests can be run without access to an IDDM
instance. Most tests (except those in `KeycloakIntegrationTests`) can be run without access to a Keycloak server. Tests
in `KeycloakIntegrationTests` can run against a local Keycloak server after following the instructions below.

The project's file structure and [pom.xml](pom.xml) demonstrate how to fulfill all JAR content requirements. It builds a
fat JAR with bundled dependencies and includes resource files in the output. You can replicate this configuration in
your project by setting up the same general package/directory structure and using the same compile elements in your
`pom.xml`. Then a suitable JAR can be built by simply invoking `mvn package` on the command line with an appropriate JDK
and maven version installed.

### Local Development

### Setting up a local Keycloak server

Running a local [Keycloak](https://www.keycloak.org/) server requires a basic understanding of how to use Docker on a
local system, including starting, stopping, and executing
commands on containers. Check out https://docs.docker.com/get-started/ and https://docker-curriculum.com/ for help on
getting started.

1. Use Docker to create a local Keycloak instance by following instructions provided by
   Keycloak: https://www.keycloak.org/getting-started/getting-started-docker.
2. Create a new Keycloak realm called "iddm-sdk".
3. Load the sample data provided (in `/tests/resources/`) by running the `main` method in
   `/tests/java/local.keycloak.LoadKeycloakSampleData`.


================================================
FILE: iddm-sdk-custom-connector/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>local.demo</groupId>
  <artifactId>iddm-sdk-custom-connector</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <version>1.18.36</version>
    </dependency>
    <dependency>
      <groupId>org.apache.commons</groupId>
      <artifactId>commons-lang3</artifactId>
      <version>3.17.0</version>
    </dependency>
    <dependency>
      <groupId>com.google.guava</groupId>
      <artifactId>guava</artifactId>
      <version>33.3.1-jre</version>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <version>4.11.0</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>com.unboundid</groupId>
      <artifactId>unboundid-ldapsdk</artifactId>
      <version>7.0.1</version>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.11.3</version>
    </dependency>
    <dependency>
      <groupId>org.apache.derby</groupId>
      <artifactId>derbyclient</artifactId>
      <version>10.14.2.0</version>
    </dependency>
    <dependency>
      <groupId>org.apache.httpcomponents</groupId>
      <artifactId>httpclient</artifactId>
      <version>4.5.14</version>
    </dependency>
    <dependency>
      <groupId>com.squareup.okhttp3</groupId>
      <artifactId>okhttp</artifactId>
      <version>4.12.0</version>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.17.2</version>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-params</artifactId>
      <version>5.11.3</version>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.assertj</groupId>
      <artifactId>assertj-core</artifactId>
      <version>3.27.2</version>
      <scope>compile</scope>
    </dependency>
    <dependency>
      <groupId>com.radiantlogic</groupId>
      <artifactId>iddm-sdk</artifactId>
      <version>8.1.4-beta.2-SNAPSHOT</version>
      <!-- Do not include the IDDM-SDK in the fat JAR. It's unnecessary and can cause conflicts. -->
      <scope>provided</scope>
    </dependency>
  </dependencies>

  <!--  Added to build a JAR with all dependencies. Used for testing locally with Gradle in ROS v7.4. -->
  <build>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>2.3.1</version>
          <configuration>
            <source>1.8</source>
            <target>1.8</target>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
    <plugins>
      <!-- any other plugins -->
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
    </plugins>
  </build>


</project>


================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/CompoundRequest.java
================================================
package local.keycloak;


import com.radiantlogic.iddm.base.Request;
import java.util.ArrayList;
import java.util.List;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;

/** Compound request. Wrapper class. Needed because of Request interface. */
@EqualsAndHashCode
@Getter
@ToString
public class CompoundRequest implements Request {

  private final List<SimpleRequest> requests = new ArrayList<>();

  public CompoundRequest addRequest(final SimpleRequest request) {
    this.requests.add(request);
    return this;
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/HttpStatus.java
================================================
package local.keycloak;

import com.radiantlogic.iddm.base.StatusCode;
import java.util.Optional;

/**
 * Custom {@link StatusCode} implementation used by the {@link KeycloakConnector} and
 * {@link KeycloakClient} for representing response code from the Keycloak REST API.
 * This class is not included in the actual SDK. It's left to the user to add if dseired.
 */
public enum HttpStatus implements StatusCode {

  OK("OK", 200),
  NOT_FOUND("Not Found", 404),
  INTERNAL_SERVER_ERROR("Internal Server Error", 500);

  private final String name;
  private final int value;

  HttpStatus(String name, int value) {
    this.name = name;
    this.value = value;
  }

  public static Optional<HttpStatus> valueOf(int statusCode) {
    HttpStatus httpStatus;
    switch (statusCode) {
      case 200:
        httpStatus = HttpStatus.OK;
        break;
      case 404:
        httpStatus = HttpStatus.NOT_FOUND;
        break;
      case 500:
        httpStatus = HttpStatus.INTERNAL_SERVER_ERROR;
        break;
      default:
        return Optional.empty();
    }
    return Optional.of(httpStatus);
  }

  @Override
  public String asString() {
    return this.name;
  }

  @Override
  public int asInt() {
    return this.value;
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/KeycloakClient.java
================================================
package local.keycloak;

import static com.radiantlogic.iddm.base.InjectableProperties.CUSTOM_DATASOURCE_PROPERTIES;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.annotations.ManagedComponent;
import com.radiantlogic.iddm.annotations.Property;
import com.radiantlogic.iddm.base.Logger;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import java.io.IOException;
import java.time.Instant;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import okhttp3.FormBody;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import org.apache.commons.lang3.StringUtils;

@ManagedComponent
public class KeycloakClient {

  private final ReadOnlyProperties connectionProperties;
  private final Logger logger;

  @AllArgsConstructor
  private static class BearerToken {

    private final String token;
    private final Instant expiration;

    public boolean isExpired() {
      return expiration.isBefore(Instant.now());
    }

    @Override
    public String toString() {
      return token;
    }
  }

  private BearerToken bearerToken = new BearerToken(StringUtils.EMPTY, Instant.ofEpochSecond(0L));

  public KeycloakClient(
      @Property(name = CUSTOM_DATASOURCE_PROPERTIES) ReadOnlyProperties connectionProperties,
      final Logger logger
  ) {
    this.connectionProperties = connectionProperties;
    this.logger = logger;
  }

  /** Returns the base URL the client is configured to use for all requests. */
  public String getBaseUrl() {
    return buildBaseUrl().build().toString();
  }

  public boolean canConnect() {
    try {
      if (bearerToken.isExpired()) {
        getToken();
      }
    } catch (IllegalStateException ex) {
      logger.info("Caught exception while trying to test connection. Assuming the connection failed.", ex);
      return false;
    }

    return !bearerToken.isExpired();
  }

  public ResponseEntity<String> authenticatedGet(@NonNull final SimpleRequest simpleRequest) {
    logger.info("Starting authenticated GET request...");

    // Request will be authenticated, so make sure token it valid
    if (bearerToken.isExpired()) {
      logger.info("Token is expired, getting new token...");
      getToken();
    }

    // Build the URL
    Object port = connectionProperties.get("port");
    HttpUrl.Builder urlBuilder = buildBaseUrl()
        .addPathSegments(
            "admin/realms/" + connectionProperties.get(
                "realm").toString() + simpleRequest.getPath());
    simpleRequest.getQueryParams().forEach(urlBuilder::addQueryParameter);
    HttpUrl url = urlBuilder.build();

    logger.info("Sending GET request to url: {}", url);

    // Build the request
    okhttp3.Request request = new okhttp3.Request.Builder()
        .url(url)
        .get()
        .addHeader("Authorization", bearerToken.toString())
        .build();

    // Execute the request
    return execute(request);
  }

  /** Use connection properties to initialize a URL builder. */
  private HttpUrl.Builder buildBaseUrl() {
    Object port = connectionProperties.get("port");
    return
        new HttpUrl.Builder()
            .scheme("http")
            .host(connectionProperties.get("host").toString())
            .port(
                (port instanceof String) ? Integer.parseInt((String) port) : (Integer) port);
  }

  private ResponseEntity<String> execute(Request request) {
    logger.info("Executing request to {}", request.url());
    OkHttpClient client = new OkHttpClient().newBuilder().build();
    try (Response response = client.newCall(request).execute()) {

      if (response.isSuccessful()) {
        logger.info("Request successful");
        return new ResponseEntity<>(HttpStatus.OK,
            response.body() == null ? null : response.body().string());
      }

      logger.error("Request failed with status code: {}", response.code());
      HttpStatus httpStatus = HttpStatus
          .valueOf(response.code())
          .orElseThrow(() -> new IllegalArgumentException(
              String.format("Unable to map status code value %d to an %s value.",
                  response.code(), this.getClass().getName())
          ));

      return new ResponseEntity<>(httpStatus, response.message());
    } catch (IOException e) {
      logger.error(e, "Problem occurred while executing request to {}", request.url());
      throw new RuntimeException(e); // todo: replace exception type
    }
  }


  /**
   * Get and store a new authentication token, throwing a {@code IllegalStateException}
   * if any errors occur.
   */
  private void getToken() {

    FormBody formBody = new FormBody.Builder()
        .addEncoded("grant_type", "password")
        .addEncoded("client_id", "admin-cli")
        .addEncoded("username", connectionProperties.get("username").toString())
        .addEncoded("password", connectionProperties.get("password").toString())
        .build();

    Object port = connectionProperties.get("port");
    HttpUrl tokenUrl = new HttpUrl.Builder().scheme("http")
        .host(connectionProperties.get("host").toString())
        .port(
            (port instanceof String) ? Integer.parseInt((String) port) : (Integer) port)
        .addPathSegments(
            "realms/master/protocol/openid-connect/token").build();

    okhttp3.Request tokenRequest = new okhttp3.Request.Builder()
        .url(tokenUrl)
        .method("POST", formBody)
        .addHeader("Content-Type", "application/x-www-form-urlencoded")
        .build();

    OkHttpClient client = new OkHttpClient().newBuilder()
        .build();

    try (Response response = client.newCall(tokenRequest).execute()) {

      if (!response.isSuccessful() || response.body() == null) {
        throw new IllegalStateException("Unable to retrieve token: " + response.message());
      }

      ObjectMapper objectMapper = new ObjectMapper();
      JsonNode node = objectMapper.readTree(response.body().string());
      if (!node.has("access_token")) {
        throw new IllegalStateException("Keycloak server did not return a token in the response");
      }

      // Save the token
      String token = "Bearer " + node.get("access_token").asText();
      Instant expiration = Instant.now().plusSeconds(node.get("expires_in").asLong());
      bearerToken = new BearerToken(token, expiration);
      logger.info("Token retrieved successfully");
    } catch (IOException ex) {
      logger.error(ex, "Problem occurred while getting token.");
      throw new IllegalStateException("Problem occurred while getting token.", ex);
    }
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/KeycloakConnector.java
================================================
package local.keycloak;

import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.annotations.CustomConnector;
import com.radiantlogic.iddm.base.LdapResponse;
import com.radiantlogic.iddm.base.LdapResultCode;
import com.radiantlogic.iddm.base.LdapSearchResponse;
import com.radiantlogic.iddm.base.Logger;
import com.radiantlogic.iddm.base.ReadOperations;
import com.radiantlogic.iddm.base.SearchResultEntry;
import com.radiantlogic.iddm.base.TestConnectionOperations;
import com.radiantlogic.iddm.base.TestConnectionRequest;
import com.radiantlogic.iddm.base.TestConnectionResponse;
import com.radiantlogic.iddm.base.TypeConverter;
import com.radiantlogic.iddm.base.Uri;
import java.util.ArrayList;
import java.util.List;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

@CustomConnector(metaJsonFile = "keycloak.json", typeConverters = LdapToRestConverter.class)
public class KeycloakConnector implements
    ReadOperations<CompoundRequest, LdapResponse<?>>,
    TestConnectionOperations<TestConnectionRequest, TestConnectionResponse> {

  private final KeycloakClient client;

  private final ResponseConverter responseConverter;
  private final Logger logger;

  public KeycloakConnector(@NonNull final KeycloakClient client, @NonNull final ResponseConverter responseConverter,
      final Logger logger) {
    this.client = client;
    this.responseConverter = responseConverter;
    this.logger = logger;
  }

  /**
   * Connector implementing the logic for handling requests.
   *
   * @param compoundRequest describing the search to perform.
   * @return response entity with a status indicating if Keycloak successfully fulfilled the
   *     request and any data that was returned. A {@link TypeConverter} should be used to prepare
   *     the returned data for LDAP and apply the appropriate LDAP status code, which may differ
   *     from the code returned by the connector. For example, the connector may return OK when
   *     no result is returned for a BASE search. But the {@link TypeConverter} should return that
   *     as an LDAP 32 - NO_SUCH_OBJECT error.
   */
  @Override
  public LdapResponse<?> search(final CompoundRequest compoundRequest) {
    logger.info("Starting search with request {}", compoundRequest);
    List<SearchResultEntry> data = new ArrayList<>();

    // Process each request
    for (SimpleRequest request : compoundRequest.getRequests()) {

      // Send request to the Keycloak server
      ResponseEntity<String> response = client.authenticatedGet(request);
      if (response.getStatus() != HttpStatus.OK) {
        return new LdapResponse<>(LdapResultCode.OPERATIONS_ERROR,
            "Server returned response: " + response.getStatus());
      }

      // Convert response into a list of strings then add it to the aggregated result
      List<SearchResultEntry> responseEntities = responseConverter.convert(response.getData());
      request.postProcessFilter(responseEntities);
      data.addAll(responseEntities);
    }

    // Successfully handled request
    logger.info("Finished search.");
    return new LdapSearchResponse(LdapResultCode.SUCCESS, data);
  }

  @Override
  public TestConnectionResponse testConnection(TestConnectionRequest request) {

    // Do not ignore the actual request. Instead, support testing connections only to the server
    //  our client is already configured to use.
    Uri requestTarget = request.getTarget();
    Uri clientTarget = Uri.fromString(client.getBaseUrl());
    boolean sameScheme = StringUtils.equalsIgnoreCase(requestTarget.getScheme(), clientTarget.getScheme());
    boolean sameAuthority = StringUtils.equalsIgnoreCase(requestTarget.getAuthority(), clientTarget.getAuthority());
    boolean isTestSupported = (requestTarget == Uri.EMPTY) || (sameScheme && sameAuthority);

    if (!isTestSupported) {
      return new TestConnectionResponse(false, request.getTarget());
    }

    boolean canConnect = false;
    try {
      canConnect = client.canConnect();
    } catch (Exception ex) {
      // ...do nothing...
    }
    return new TestConnectionResponse(canConnect, request.getTarget());
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/LdapToRestConverter.java
================================================
package local.keycloak;

import com.google.common.collect.ImmutableMap;
import com.radiantlogic.iddm.RDN;
import com.radiantlogic.iddm.SearchFilter;
import com.radiantlogic.iddm.annotations.ManagedComponent;
import com.radiantlogic.iddm.annotations.Property;
import com.radiantlogic.iddm.base.Field;
import com.radiantlogic.iddm.base.InjectableProperties;
import com.radiantlogic.iddm.base.LdapRequest;
import com.radiantlogic.iddm.base.Logger;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import com.radiantlogic.iddm.base.Schema;
import com.radiantlogic.iddm.base.SchemaObject;
import com.radiantlogic.iddm.base.SearchScope;
import com.radiantlogic.iddm.base.TypeConverter;
import com.radiantlogic.iddm.ldap.SearchRequest;
import lombok.NonNull;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static com.radiantlogic.iddm.ValidationUtils.requireNonNull;
import static com.radiantlogic.iddm.ValidationUtils.requireState;

@ManagedComponent
public class LdapToRestConverter implements TypeConverter<LdapRequest, CompoundRequest> {

  /** Maps schema object names to Keycloak endpoints. */
  private static final Map<String, String> ENDPOINTS = new HashMap<String, String>() {{
    put("kc_users", "/users");
    put("kc_groups", "/groups");
  }};

  /** Set of LDAP filter operations supported by the connector. */
  private static final EnumSet<SearchFilter.Type> SUPPORTED_FILTER_TYPES =
      EnumSet.of(SearchFilter.Type.AND, SearchFilter.Type.EQUAL, SearchFilter.Type.PRESENCE);

  private final ReadOnlyProperties dnObjectMapping;

  private final Schema schemas;

  private final ReadOnlyProperties targetSchemaObjects;

  private final ReadOnlyProperties primaryKeyAttributes;

  private final Logger logger;

  public LdapToRestConverter(
      @Property(name = InjectableProperties.DN_TO_SCHEMA_MAPPING) final ReadOnlyProperties viewMapping,
      @Property(name = InjectableProperties.SCHEMAS) final Schema schemas,
      @Property(name = InjectableProperties.TARGET_SCHEMA_OBJECTS) final ReadOnlyProperties targetSchemaObjects,
      @Property(name = InjectableProperties.PRIMARY_KEY_ATTRIBUTES) final ReadOnlyProperties primaryKeyAttributes,
      final Logger logger
  ) {
    this.dnObjectMapping = viewMapping;
    this.schemas = schemas;
    this.targetSchemaObjects = targetSchemaObjects;
    this.primaryKeyAttributes = primaryKeyAttributes;
    this.logger = logger;
  }

  @Override
  public CompoundRequest convert(final LdapRequest source) {
    if (source instanceof SearchRequest) {
      return convertSearch((SearchRequest) source);
    }
    throw new IllegalArgumentException("Unsupported request type");
  }

  /**
   * searching for users and groups.
   * <p>
   * Currently supports searching for users using EQUALITY and AND filters. An exception is thrown
   * if any other filter types are detected; this is to help be clear to the caller about
   * is supported and to avoid unexpected behavior.
   */
  private CompoundRequest convertSearch(final SearchRequest searchRequest) {
    logger.info("Converting LDAP search request: {}", searchRequest);

    requireState(
        SUPPORTED_FILTER_TYPES.contains(searchRequest.getFilter().getType()),
        "%s supports only AND, EQUALITY, and PRESENCE filters",
        this.getClass().getName());

    // Build a request for each object that needs to be searched
    CompoundRequest compoundRequest = new CompoundRequest();

    List<SchemaObject> schemaObjects = getSchemaObjectsToSearch(searchRequest);
    for (SchemaObject schemaObject : schemaObjects) {

      SimpleRequest baseRequest = createSearchRequestForSchemaObject(searchRequest, schemaObject);
      Optional<SimpleRequest> requestOptional = addFilterToSearchRequest(baseRequest, schemaObject,
          searchRequest.getFilter());

      if (requestOptional.isPresent()) {
        compoundRequest.addRequest(requestOptional.get());
      }
    }

    logger.info("LDAP search request converted to CompoundRequest: {}", compoundRequest);

    // TODO (M.Silva, 21Jan2025) -- Need to account for static filters that might have been applied to the view.

    return compoundRequest;
  }

  /**
   * Returns a list of {@link SchemaObject}s that should be searched based on the search's
   * base DN and scope.
   * <p>
   * This method is an optimization intended to reduce the number of schema objects and Keycloak
   * endpoints that are checked when the connector processes the search request.
   */
  private List<SchemaObject> getSchemaObjectsToSearch(final SearchRequest source) {

    List<SchemaObject> schemaObjects = new ArrayList<>();

    @SuppressWarnings("unchecked")
    List<String> schemaObjectNames = (List<String>) targetSchemaObjects.get("schemaObjects");
    if (schemaObjectNames == null) {
      return Collections.emptyList();
    }

    for (String name : schemaObjectNames) {
      schemaObjects.add(
          schemas.getSchemaObject(name)
              .orElseThrow(() -> new IllegalStateException("Could not find schema object " + name))
      );
    }

    // For base searches, remove any schema objects that do not contain the RDN attribute.
    //  This prevents us from searching objects that we know will never contain the
    //  entry we're looking for.
    if (source.getSearchScope() == SearchScope.BASE) {
      String rdnAttribute = source.getBaseDN().getRDNs().get(0).getAttributeName();
      schemaObjects.removeIf(schemaObject -> !schemaObject.containsField(rdnAttribute));
    }

    return schemaObjects;
  }


  /**
   * Returns a {@link SimpleRequest} with a path determined by the {@link SchemaObject} and
   * query parameters determined by the incoming search's {@link SearchScope}.
   * <p>
   * The caller should perform additional processing on the returned {@link SimpleRequest} to
   * apply additional constraints such as filters.
   */
  private SimpleRequest createSearchRequestForSchemaObject(
      final SearchRequest source, final SchemaObject schemaObject
  ) {

    // Find the Keycloak endpoints that contain the objects needed.
    String path = requireNonNull(
        ENDPOINTS.get(schemaObject.getName()),
        String.format("Unable to find a Keycloak REST endpoint associated with the schema object type '%s'.",
            schemaObject.getName())
    );

    SimpleRequest baseRequest = SimpleRequest.create(path, logger);

    // When performing a BASE search, the base DN's RDN contains the values we need
    //  for querying Keycloak. (Contrast this with non-BASE searches where we look
    //  only at the LDAP filter to get the query params.)
    if (source.getSearchScope() == SearchScope.BASE) {

      // The schema (in IDDM) might use multiple attributes to create the LDAP entry's primary
      //  key. And both the schema and naming context view (in IDDM) might define a
      //  custom "display RDN". We need to account for this when extracting query parameters
      //  from the search's base DN.
      final RDN rdn = source.getBaseDN().getRDNs().get(0);
      boolean dnIsUsingCustomPrimaryKey = !primaryKeyAttributes.isEmpty();
      final Map<String, Object> rdnComponents =
          dnIsUsingCustomPrimaryKey ?
              // Display RDN is using custom mapping; need to reverse the mapping to get the values
              primaryKeyAttributes.asMap() :
              // Using standard RDN
              ImmutableMap.of(rdn.getAttributeName(), rdn.getAttributeValue());

      for (Map.Entry<String, Object> component : rdnComponents.entrySet()) {

        String rdnAttribute = component.getKey();
        String rdnValue = component.getValue().toString();

        // TODO (M.Silva, 24Jan2025) - Already established field is present. Refactor to remove warning.
        Field field = schemaObject.getField(rdnAttribute).get();

        boolean isCustomProperty = field.getTags().contains("custom");

        if (isCustomProperty) {
          baseRequest.addQueryParam("q",
              String.format("%s:%s", field.getName(), rdnValue)
          );
        } else {
          baseRequest.addQueryParam(
              field.getName(), rdnValue
          );
        }
      }
    }

    return baseRequest;
  }

  private Optional<SimpleRequest> addFilterToSearchRequest(
      @NonNull final SimpleRequest request,
      @NonNull final SchemaObject schemaObject,
      @NonNull final SearchFilter complexFilter) {

    Deque<SearchFilter> stack = new ArrayDeque<>();
    stack.add(complexFilter);
    assert !stack.isEmpty() : "Documenting expectation that the filter is not empty.";

    while (!stack.isEmpty()) {

      SearchFilter filter = stack.pop();

      // Expand conditional filters (ex: AND) so each condition can be processed.
      if (filter.isConditional()) {
        requireState(filter.getType().equals(SearchFilter.Type.AND),
            "%s does not support %s filters.", this.getClass().getName(), filter.getType().name());
        stack.addAll(filter.getComponents());
        continue;
      }

      // Process "objectclass" attribute if it appears in the filter.
      boolean isObjectClassFilter = "objectclass".equalsIgnoreCase(filter.getAttribute());
      if (isObjectClassFilter) {

        boolean isObjectClassExcluded = !"*".equalsIgnoreCase(filter.getValue()) &&
            !schemaObject.getObjectClass().equalsIgnoreCase(filter.getValue());

        if (isObjectClassExcluded) {
          return Optional.empty();
        }
        continue;
      }

      Optional<Field> fieldOptional = schemaObject.getField(filter.getAttribute());
      if (!fieldOptional.isPresent()) {
        // Keycloak ignores unknown query parameters when filtering results.
        //  We do not want to allow this behavior. Instead, we want to enforce LDAP-style
        //  filtering where we should get no results.
        return Optional.empty();
      }

      // Process filter condition that targets a specific attribute.
      // Keycloak doesn't support presence filters; special post-processing is required
      //  for the connector to support this filter.
      boolean isFilterSupportedByKeycloak = filter.getType() != SearchFilter.Type.PRESENCE;
      if (isFilterSupportedByKeycloak) {
        handleKeycloakSupportedFilter(fieldOptional.get(), request, filter);
      } else {
        handlePresenceFilter(request, filter);
      }
    }

    return Optional.of(request);
  }

  private static void handleKeycloakSupportedFilter(
      final Field field, final SimpleRequest request, final SearchFilter filter
  ) {

    boolean isCustomProperty = field.getTags().contains("custom");

    if (isCustomProperty) {
      request.addQueryParam("q",
          String.format("%s:%s", field.getName(), filter.getValue())
      );
    } else {
      request.addQueryParam(
          field.getName(), filter.getValue()
      );
    }
  }

  private static void handlePresenceFilter(final SimpleRequest request, final SearchFilter filter) {
    // Predicate defining which elements to filter out of the results.
    request.setPredicate(
        searchResultEntry -> {

          Map<String, Object> entry = searchResultEntry.asUnmodifiableMap();

          // Check the built-in attributes
          if (entry.get(filter.getAttribute()) == null) {
            return false;
          }

          // Check any custom attributes
          return ((Map<?, ?>) entry.getOrDefault("attributes", Collections.emptyMap()))
              .getOrDefault(filter.getAttribute(), null) == null;
        }
    );
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/ResponseConverter.java
================================================
package local.keycloak;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.annotations.ManagedComponent;
import com.radiantlogic.iddm.base.SearchResultEntry;
import com.radiantlogic.iddm.base.TypeConverter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;


@ManagedComponent

public class ResponseConverter implements TypeConverter<String, List<SearchResultEntry>> {


  @Override
  public List<SearchResultEntry> convert(String data) {

    List<Map<String, Object>> entries;
    try {
      entries = new ObjectMapper().readValue(data, new TypeReference<List<Map<String, Object>>>() {
      });
    } catch (JsonProcessingException ex) {
      // TODO (M.Silva, 27Jan2025) - Replace with a SDK based exception that the user is
      //  expected to use, e.g., OtherLdapException(80)
      throw new IllegalStateException(ex);
    }

    List<SearchResultEntry> searchResults = new ArrayList<>(entries.size());

    for (Map<String, Object> result : entries) {

      SearchResultEntry toReturn = new SearchResultEntry();

      for (Map.Entry<String, Object> entry : result.entrySet()) {

        // deal with the custom attributes
        if (entry.getKey().equalsIgnoreCase("attributes")) {
          for (Map.Entry<String, Object> customAttribute : ((Map<String, Object>) entry.getValue()).entrySet()) {
            toReturn.put(customAttribute.getKey(), customAttribute.getValue().toString());
          }
        }
        // expect the data to be a string.
        else {
          toReturn.put(entry.getKey(), entry.getValue().toString());
        }
      }

      searchResults.add(toReturn);
    }

    return searchResults;
  }
}





================================================
FILE: iddm-sdk-custom-connector/src/main/java/local/keycloak/SimpleRequest.java
================================================
package local.keycloak;

import com.radiantlogic.iddm.ValidationUtils;
import com.radiantlogic.iddm.base.Logger;
import com.radiantlogic.iddm.base.SearchResultEntry;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;

@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
@EqualsAndHashCode
@Getter
@ToString
public class SimpleRequest {

  private final String path;

  private final Map<String, String> queryParams = new HashMap<>();

  private final Map<String, String> requestBody = new HashMap<>();

  /** Predicate defining which elements to remove from the results. */
  @Setter
  private Predicate<SearchResultEntry> predicate;

  public static SimpleRequest create(@NonNull final String path) {
    ValidationUtils.requireNotBlank(path);
    return new SimpleRequest(path);
  }

  public static SimpleRequest create(@NonNull final String path, final Logger logger) {
    ValidationUtils.requireNotBlank(path);
    logger.info("Creating request for path '{}'", path);
    return new SimpleRequest(path);
  }

  public SimpleRequest addQueryParam(@NonNull final String key, @NonNull final String value) {
    ValidationUtils.requireNotBlank(key, value);
    queryParams.put(key, value);
    return this;
  }

  public void postProcessFilter(@NonNull List<SearchResultEntry> data) {
    if (predicate == null) {
      return;
    }
    data.removeIf(predicate);
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/main/resources/local/keycloak/keycloak.json
================================================
{
  "name": "Keycloak",
  "description": "Demo implementation of an SDK-based connector for performing search operations against a Keycloak datasource.",
  "backendCategory": "custom",
  "userCreated": true,
  "icon": "",
  "isSchemaExtractable": false,
  "meta": [
    {
      "name": "host",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "port",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": "",
      "dataType": "NUMBER",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "username",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "password",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": "",
      "dataType": "PASSWORD",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "realm",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    }
  ]
}


================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/KeycloakClientTest.java
================================================
package local.keycloak;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import com.radiantlogic.iddm.test.TestLogger;
import lombok.SneakyThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.platform.commons.util.StringUtils;

@Disabled("Tests requires a live Keycloak server. None is current available in GitLab pipelines.")
class KeycloakClientTest {

  ReadOnlyProperties connectionProperties;

  KeycloakClient client;

  @BeforeEach
  void setUp() {

    connectionProperties = ReadOnlyProperties.builder()
        .put("host", "localhost")
        .put("port", 8080)
        .put("username", "admin")
        .put("password", "admin")
        .put("realm", "iddm-sdk")
        .build();

    client = new KeycloakClient(connectionProperties, new TestLogger());
  }

  @Test
  @SneakyThrows
  void getUsers() {

    ResponseEntity<String> actual = client.authenticatedGet(SimpleRequest.create("/users"));

    assertNotNull(actual);
    assertEquals(HttpStatus.OK, actual.getStatus());
    assertTrue(StringUtils.isNotBlank(actual.getData()));

    JsonNode data = new ObjectMapper().readTree(actual.getData());
    assertTrue(data.isArray());
    assertFalse(data.isEmpty());
  }

  @Test
  @SneakyThrows
  void getGroups() {

    ResponseEntity<String> actual = client.authenticatedGet(SimpleRequest.create("/groups"));

    assertEquals(HttpStatus.OK, actual.getStatus());

    JsonNode data = new ObjectMapper().readTree(actual.getData());
    assertTrue(data.isArray());
    assertFalse(data.isEmpty());
  }

  @Test
  @SneakyThrows
  void connect() {
    assertTrue(client.canConnect());
  }
}


================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/KeycloakConnectorTest.java
================================================
package local.keycloak;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.base.LdapResultCode;
import com.radiantlogic.iddm.base.SearchResultEntry;
import com.radiantlogic.iddm.base.TestConnectionRequest;
import com.radiantlogic.iddm.base.TestConnectionResponse;
import com.radiantlogic.iddm.base.Uri;
import com.radiantlogic.iddm.test.TestLogger;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.SneakyThrows;
import org.junit.jupiter.api.Assumptions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

class KeycloakConnectorTest {

  KeycloakClient client;

  ObjectMapper objectMapper = new ObjectMapper();

  ResponseConverter responseConverter = new ResponseConverter();

  TestLogger testLogger = new TestLogger();


  /** Returns a {@link File} for an item in the test {@code resources} folder. */
  private File getResourceFile(final String filename) throws FileNotFoundException, URISyntaxException {
    URL url = this.getClass().getClassLoader().getResource(filename);
    if (url == null) {
      throw new FileNotFoundException("Could not find resource file: " + filename);
    }
    File file = new File(url.toURI());
    if (!file.exists()) {
      throw new FileNotFoundException("Could not find resource file: " + filename);
    }
    return file;
  }

  /** Loads the resource file's contents in a {@link JsonNode}. */
  private JsonNode readResourceFile(final String filename) throws IOException, URISyntaxException {
    return objectMapper.readTree(getResourceFile(filename));
  }

  /** Deserialize the resource file's contents into a type {@code T}. */
  private <T> T readResourceFile(final String filename, TypeReference<T> typeReference)
      throws IOException, URISyntaxException {
    return objectMapper.readValue(getResourceFile(filename), typeReference);
  }


  @BeforeEach
  @SneakyThrows
  void beforeEach() {

    // Mock behavior of the Keycloak backend API
    client = mock(KeycloakClient.class);
    when(
        client.authenticatedGet(
            eq(SimpleRequest.create("/users"))
        )
    )
        .thenReturn(new ResponseEntity<>(HttpStatus.OK,
            readResourceFile("users.json").toString()));
    when(
        client.authenticatedGet(
            eq(SimpleRequest.create("/groups"))
        )
    )
        .thenReturn(new ResponseEntity<>(HttpStatus.OK,
            readResourceFile("groups.json").toString()));
  }

  // TODO (M.Silva, 27Jan2025) -- Update test comments for clarity.
  @DisplayName("Aggregated search results")
  @Test
  @SneakyThrows
  void search() {

    // Given Keycloak has users and groups...
    Assumptions.assumeTrue(client != null);

    // ...then should be aggregated into a list of entries
    Set<String> expectedObjects = new HashSet<>();
    objectMapper.readTree(TestData.usersString)
        .forEach(
            jsonNode -> expectedObjects.add(jsonNode.get("username").asText())
        );
    objectMapper.readTree(TestData.groupsString)
        .forEach(
            jsonNode -> expectedObjects.add(jsonNode.get("name").asText())
        );

    Assumptions.assumeTrue(expectedObjects.size() == 15);
    ResponseEntity<Set<String>> expectedResponse = new ResponseEntity<>(LdapResultCode.SUCCESS, expectedObjects);

    // When the connector receives a compound response
    CompoundRequest compoundRequest = new CompoundRequest()
        .addRequest(SimpleRequest.create("/users"))
        .addRequest(SimpleRequest.create("/groups"));
    KeycloakConnector connector = new KeycloakConnector(client, responseConverter, new TestLogger());

    // Then the connector should return the aggregated data
    @SuppressWarnings("unchecked")
    ResponseEntity<List<SearchResultEntry>> actualResponse =
        (ResponseEntity<List<SearchResultEntry>>) connector.search(compoundRequest);

    // Comparing only the object IDs
    assertEquals(expectedResponse.getStatus(), actualResponse.getStatus());
    assertEquals(expectedResponse.getData(),
        actualResponse.getData().stream().map(searchResultEntry -> {
              Map<String, Object> map = searchResultEntry.asUnmodifiableMap();
              return map.containsKey("username") ?
                  map.get("username") : // user entry
                  map.get("name"); // group entry
            })
            .collect(
                Collectors.toSet()));
  }


  @DisplayName("Test connection")
  @ParameterizedTest
  @MethodSource
  void testConnection(final KeycloakClient client, final TestConnectionRequest request,
      final TestConnectionResponse expectedResponse) {

    // Given a connector
    KeycloakConnector connector = new KeycloakConnector(client, responseConverter, testLogger);

    // When it receives a test connection request
    TestConnectionResponse actualResponse = connector.testConnection(request);

    // Then the connection should successfully process the request
    assertThat(actualResponse).isEqualTo(expectedResponse);
  }

  /** Test cases for test connection operations. */
  static List<Arguments> testConnection() {

    KeycloakClient connectedClient = mock(KeycloakClient.class);
    when(connectedClient.canConnect()).thenReturn(true);
    when(connectedClient.getBaseUrl()).thenReturn("http://localhost:8080");

    KeycloakClient disconnectedClient = mock(KeycloakClient.class);
    when(disconnectedClient.canConnect()).thenReturn(false);
    when(disconnectedClient.getBaseUrl()).thenReturn("http://localhost:8080");

    // Test case
    Arguments.ArgumentSet successEmptyUri = Arguments.argumentSet(
        "Keycloak server is reachable & request contains empty URI",
        // Given the client can connect to Keycloak server
        connectedClient,
        // When IDDM sends test connection request with an empty URI
        new TestConnectionRequest(Uri.EMPTY),
        // Then the connection should be successful
        new TestConnectionResponse(true, Uri.EMPTY)
    );

    // Test case
    Arguments.ArgumentSet unreachableEmptyUri = Arguments.argumentSet(
        "Keycloak server is unavailable",
        // Given the client can connect to Keycloak server
        disconnectedClient,
        // When IDDM sends test connection request with an empty URI
        new TestConnectionRequest(Uri.EMPTY),
        // Then the connection should fail
        new TestConnectionResponse(false, Uri.EMPTY)
    );

    // Test case
    Arguments.ArgumentSet reachableMatchingTarget = Arguments.argumentSet(
        "Keycloak server is reachable and the request targets the server the client already connects to",
        // Given the client can connect to Keycloak server
        connectedClient,
        // When IDDM sends test connection request targeting a server the client
        //  is NOT configured to use
        new TestConnectionRequest(Uri.fromString("http://localhost:8080")),
        // Then the connection should fail
        new TestConnectionResponse(true, Uri.fromString("http://localhost:8080"))
    );

    // Test case
    Arguments.ArgumentSet reachableButExternalUri = Arguments.argumentSet(
        "Keycloak server is reachable but request is for a different resource.",
        // Given the client can connect to Keycloak server
        connectedClient,
        // When IDDM sends test connection request targeting a server the client
        //  is NOT configured to use
        new TestConnectionRequest(Uri.fromString("http://foobar.local")),
        // Then the connection should fail
        new TestConnectionResponse(false, Uri.fromString("http://foobar.local"))

    );

    return Arrays.asList(
        successEmptyUri, unreachableEmptyUri, reachableMatchingTarget, reachableButExternalUri
    );
  }
}


================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/KeycloakIntegrationTests.java
================================================
package local.keycloak;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.params.provider.Arguments.arguments;

import com.google.common.collect.ImmutableMap;
import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.SearchFilter;
import com.radiantlogic.iddm.base.LdapResultCode;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import com.radiantlogic.iddm.base.Schema;
import com.radiantlogic.iddm.base.SearchScope;
import com.radiantlogic.iddm.base.TestConnectionRequest;
import com.radiantlogic.iddm.base.TestConnectionResponse;
import com.radiantlogic.iddm.ldap.SearchRequest;
import com.radiantlogic.iddm.test.TestLogger;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

/** Tests connector against a real Keycloak data source . */
@Disabled("Tests requires a live Keycloak server. None is current available in GitLab pipelines.")
public class KeycloakIntegrationTests {

  KeycloakClient client;

  ResponseConverter responseConverter = new ResponseConverter();

  ReadOnlyProperties connectionProperties = TestData.connectionProperties;
  Schema schema = TestData.schema;
  ReadOnlyProperties views = TestData.views;
  ReadOnlyProperties targetSchemaObjects = TestData.targetSchemaObjects;
  ReadOnlyProperties primaryKeyAttributes = new ReadOnlyProperties(ImmutableMap.of());

  final TestLogger testLogger = new TestLogger();

  final LdapToRestConverter requestConverter =
      new LdapToRestConverter(views, schema, targetSchemaObjects, primaryKeyAttributes, testLogger);


  @BeforeEach
  public void beforeEach() {
    client = new KeycloakClient(connectionProperties, new TestLogger());
  }

  @DisplayName("Successful test connection to an available server")
  @Test
  void successfulTestConnection() {

    // Given a test connection request to a valid, available Keycloak server
    TestConnectionRequest request = TestConnectionRequest.from("http://localhost:8080");

    // ...and a valid connector
    KeycloakConnector connector = new KeycloakConnector(client, responseConverter, testLogger);

    // When the connector receives the request
    TestConnectionResponse response = connector.testConnection(request);

    // Then the connection should be successful
    assertThat(response.isSuccessful()).isTrue();
  }

  @DisplayName("Failed test connection to an unavailable server")
  @Test
  void failedTestConnection() {

    // Given a test connection request to a valid, available Keycloak server
    TestConnectionRequest request = TestConnectionRequest.from("http://foobarbaz:8080");

    // ...and a valid connector
    KeycloakConnector connector = new KeycloakConnector(client, responseConverter, testLogger);

    // When the connector receives the request
    TestConnectionResponse response = connector.testConnection(request);

    // Then the connection should be successful
    assertThat(response.isSuccessful()).isFalse();
  }


  @DisplayName("Search")
  @ParameterizedTest
  @MethodSource
  void search(String dn, SearchScope searchScope, String filter, int expectedNumResults) {

    // Given a search request
    SearchRequest ldapRequest = SearchRequest.create(DN.from(dn), searchScope, SearchFilter.from(filter));

    // When the request is sent to the connector
    KeycloakConnector connector = new KeycloakConnector(client, responseConverter, testLogger);

    @SuppressWarnings("unchecked")
    ResponseEntity<List<String>> responseEntity =
        (ResponseEntity<List<String>>) connector.search(requestConverter.convert(ldapRequest));

    assertEquals(LdapResultCode.SUCCESS, responseEntity.getStatus());
    assertEquals(expectedNumResults,
        responseEntity.getData().size());  // TODO (M.Silva, 22Jan2025) - Strengthen assertions
    System.out.println(Arrays.toString(responseEntity.getData().toArray()));
  }

  static Stream<Arguments> search() {
    String dn = "ou=whitehouse,o=executive";
    SearchScope scope = SearchScope.SUB;

    return Stream.of(
        arguments(dn, scope, "(objectclass=*)", 15),
        arguments(dn, scope, "(&(LASTNAME=Bush)(emailverified=true))", 1),
        arguments(dn, scope, "(party=*)", 6),
        arguments(dn, scope, "(party=Democratic)", 3),
        arguments(dn, scope, "(&(LASTNAME=Bush)(party=*))", 2),
        arguments(dn, scope, "(&(LASTNAME=*)(party=*))", 6),
        arguments(dn, scope, "(party=D)", 0),
        arguments(dn, scope, "(propertyDoesNotExist=*)", 0),
        arguments("username=quayle,ou=whitehouse,o=executive", SearchScope.BASE, "(objectclass=*)", 1),
        arguments("username=quayle,ou=whitehouse,o=executive", SearchScope.BASE, "(objectclass=group)", 0),
        arguments(dn, SearchScope.ONE, "(objectclass=*)", 15),
        arguments(dn, SearchScope.ONE, "(&(LASTNAME=Bush)(party=*))", 2)

    );
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/LdapToRestConverterTest.java
================================================
package local.keycloak;

import com.google.common.collect.ImmutableMap;
import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.SearchFilter;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import com.radiantlogic.iddm.base.Schema;
import com.radiantlogic.iddm.base.SchemaObject;
import com.radiantlogic.iddm.base.SearchScope;
import com.radiantlogic.iddm.ldap.SearchRequest;
import com.radiantlogic.iddm.test.TestLogger;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;


class LdapToRestConverterTest {

  // https://www.keycloak.org/docs-api/latest/rest-api/index.html#UserRepresentation
  SchemaObject userSchema = TestData.userSchemaObject;

  // https://www.keycloak.org/docs-api/latest/rest-api/index.html#GroupRepresentation
  SchemaObject groupSchema = TestData.groupSchemaObject;

  Schema schemas = TestData.schema;

  // Single view is associated with multiple schemas because the view hold multiple object types.
  //  This is a realistic use case. For example, having an OU by office location where the
  //  OU contains users and groups for that location.
  ReadOnlyProperties views = TestData.views;

  ReadOnlyProperties targetSchemaObjects = TestData.targetSchemaObjects;

  ReadOnlyProperties primaryKeyAttributes = new ReadOnlyProperties(ImmutableMap.of());

  LdapToRestConverter converter;

  DN dn;

  @BeforeEach
  void setUp() {
    converter = new LdapToRestConverter(views, schemas, targetSchemaObjects, primaryKeyAttributes, new TestLogger());
    dn = DN.from("ou=whitehouse,o=executive");
  }

  @DisplayName("Get all directory entries")
  @Test
  void allEntries() {

    // Given a search request
    SearchRequest ldapRequest = SearchRequest.create(
        DN.from("ou=whitehouse,o=executive"), SearchScope.SUB,
        SearchFilter.from("(objectclass=*)"));

    // When the request is sent to the converter
    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(SimpleRequest.create("/users"))
        .addRequest(SimpleRequest.create("/groups"));
    assertEquals(expected, actual);
  }

  @DisplayName("(objectclass=kcUser)")
  @Test
  void simpleFilter1() {
    // Given a search request
    SearchRequest ldapRequest = SearchRequest.create(dn, SearchScope.SUB,
        SearchFilter.from("(objectclass=kcUser)"));

    // When the request is sent to the converter
    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("(emailverified=true)")
  @Test
  void simpleFilter2() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(
            dn, SearchScope.SUB,
            SearchFilter.from("(emailverified=true)"));

    // When the request is sent to the converter
    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users").addQueryParam("emailVerified", "true")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("(lastName=Bush)")
  @Test
  void simpleFilter3() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(dn, SearchScope.SUB,
            SearchFilter.from("(lastname=Bush)"));

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users").addQueryParam("lastName", "Bush")
        );
    assertEquals(expected, actual);
  }


  @DisplayName("(&(objectclass=kcUser)(emailverified=true))")
  @Test
  void conditionalFilter1() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(dn, SearchScope.SUB,
            SearchFilter.from("(&(objectclass=kcUser)(emailverified=true))"));

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users").addQueryParam("emailVerified", "true")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("(&(lastname=Bush)(emailverified=true))")
  @Test
  void conditionalFilter2() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(dn, SearchScope.SUB,
            SearchFilter.from("(&(LASTNAME=Bush)(emailverified=true))"));

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
                .addQueryParam("emailVerified", "true")
                .addQueryParam("lastName", "Bush")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("(lastname=*)")
  @Test
  void presenceFilter1() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(dn,
            SearchScope.SUB,
            SearchFilter.from("(lastname=*)")
        );

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
        );

    // Then // TODO (M.Silva, 23Jan2025) - Need AssertJ to be able to ignore properties
    assertInstanceOf(CompoundRequest.class, actual);
    assertEquals(1, actual.getRequests().size());
    SimpleRequest simpleRequest = actual.getRequests().get(0);
    assertEquals("/users", simpleRequest.getPath());
    assertTrue(simpleRequest.getQueryParams().isEmpty());
    assertTrue(simpleRequest.getRequestBody().isEmpty());
    assertNotNull(simpleRequest.getPredicate());
  }

  @DisplayName("(party=Democratic)")
  @Test
  void customAttribute() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(dn,
            SearchScope.SUB,
            SearchFilter.from("(party=Democratic)")
        );

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
                .addQueryParam("q", "party:Democratic")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("Base search 1")
  @Test
  void baseSearch1() {

    // Given a search request
    SearchRequest ldapRequest =
        SearchRequest.create(
            DN.from("username=quayle,ou=whitehouse,o=executive"),
            SearchScope.BASE,
            SearchFilter.from("(objectclass=*)"));

    // When the request is sent to the converter

    CompoundRequest actual = converter.convert(ldapRequest);

    // Then it should return a compound request
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
                .addQueryParam("username", "quayle")
        );
    assertEquals(expected, actual);
  }

  @DisplayName("Base search with customized primary key")
  @Test
  void baseSearch2() {

    // Given a search request where the DN is customized in IDDM
    SearchRequest ldapRequest =
        SearchRequest.create(
            DN.from("username=Republican Danforth Quayle {Danforth :: Quayle :: quayle},ou=whitehouse,o=executive"),
            SearchScope.BASE,
            SearchFilter.from("(objectclass=*)")
        );

    // When the request is sent to the converter
    LdapToRestConverter converter = new LdapToRestConverter(views, schemas, targetSchemaObjects,
        ReadOnlyProperties.builder()
            .put("firstName", "Danforth")
            .put("lastName", "Quayle")
            .put("username", "quayle").build(),
            new TestLogger()
    );
    CompoundRequest actual = converter.convert(ldapRequest);

    // Then
    CompoundRequest expected = new CompoundRequest()
        .addRequest(
            SimpleRequest.create("/users")
                .addQueryParam("username", "quayle")
                .addQueryParam("firstName", "Danforth")
                .addQueryParam("lastName", "Quayle")
        );
    assertEquals(expected, actual);
  }
}


================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/LoadKeycloakSampleData.java
================================================
package local.keycloak;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.base.Logger;
import com.radiantlogic.iddm.test.TestLogger;
import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.NonNull;
import lombok.SneakyThrows;
import okhttp3.FormBody;
import okhttp3.HttpUrl;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;

/**
 * This class is a temporary utility to help load sample data provided with the project into a
 * live Keycloak server.
 * <p>
 * To use:
 * <ol>
 *   <li>Update the member variables under "Change the following configuration settings
 *  to match your environment."</li>
 *  <li>Ensure your Keycloak server is running.</li>
 *  <li>Run the {@link LoadKeycloakSampleData#main(String[])} method to load the data</li>
 * </ol>
 */
public class LoadKeycloakSampleData {

  private static final Logger log = new TestLogger();

  /** Change the following configuration settings to match your environment. */
  private static final String hostname = "localhost";
  private static final int port = 8080;
  private static final String realm = "iddm-sdk";
  private static final String username = "admin";
  private static final String password = "admin";


  /** Do not change the following settings. */
  private static final String USERS_JSON_FILE = "users.json";
  private static final String GROUPS_JSON_FILE = "groups.json";
  private static final String MEMBERSHIP_JSON_FILE = "membership.json";


  /**
   * Entry point for loading sample data from JSON files into the Keycloak server.
   */
  public static void main(String[] args) {
    loadUsers();
    loadGroups();
    loadGroupMembership();
  }


  /**
   * Loads user information from {@code users.json} into the Keycloak server. This method assumes
   * the user information is not present on the server beforehand.
   */
  @SneakyThrows
  private static void loadUsers() {
    File resourceFile = FileUtils.getResourceFile(USERS_JSON_FILE);
    JsonNode jsonNode = new ObjectMapper().readTree(resourceFile);
    for (int i = 0; i < jsonNode.size(); i++) {
      String user = jsonNode.get(i).toString();
      HttpUrl url = buildAdminUrl("users");
      Request.Builder requestBuilder = authorizedRequestBuilder(url);
      RequestBody requestBody = RequestBody.create(user, MediaType.parse("application/json"));
      Request request = requestBuilder.post(requestBody).build();
      executeRequest(request);
    }
  }


  /**
   * Loads group information from {@code groups.json} into the Keycloak server. This method assumes
   * the group information is not present on the server beforehand.
   */
  @SneakyThrows
  private static void loadGroups() {
    File resourceFile = FileUtils.getResourceFile(GROUPS_JSON_FILE);
    JsonNode jsonNode = new ObjectMapper().readTree(resourceFile);
    for (int i = 0; i < jsonNode.size(); i++) {
      String group = jsonNode.get(i).toString();
      HttpUrl url = buildAdminUrl("groups");
      Request.Builder requestBuilder = authorizedRequestBuilder(url);
      RequestBody requestBody = RequestBody.create(group, MediaType.parse("application/json"));
      Request request = requestBuilder.post(requestBody).build();
      executeRequest(request);
    }
  }


  /**
   * Loads group membership information from {@code membership.json} into the Keycloak server.
   * This method assumes that data from {@code users.json} and {@code groups.json} is already
   * loaded into the server.
   */
  @SneakyThrows
  private static void loadGroupMembership() {
    File resourceFile = FileUtils.getResourceFile(MEMBERSHIP_JSON_FILE);
    JsonNode members = new ObjectMapper().readTree(resourceFile);
    for (JsonNode member : members) {
      String groupId = getGroupId(member.get("groupName").asText());
      String userId = getUserId(member.get("username").asText());

      HttpUrl url = buildAdminUrl("users/" + userId + "/groups/" + groupId);
      Request.Builder requestBuilder = authorizedRequestBuilder(url);

      RequestBody emptyRequestBody = RequestBody.create(new byte[0],
          MediaType.parse("application/json"));
      Request request = requestBuilder.put(emptyRequestBody).build();
      executeRequest(request);
    }
  }


  /**
   * Convenience method that returns a {@link HttpUrl} for using Keycloak REST API admin endpoints.
   */
  private static HttpUrl buildAdminUrl(@NonNull final String pathSegment) {
    return buildUrl("admin/realms/" + realm + "/" + pathSegment);
  }


  private static HttpUrl buildUrl(@NonNull final String pathSegment) {
    return new HttpUrl.Builder()
        .scheme("http")
        .host(hostname)
        .port(port)
        .addPathSegments(pathSegment).build();
  }


  /**
   * Returns a {@link Request.Builder} with the bearer token already included.
   */
  private static Request.Builder authorizedRequestBuilder(@NonNull final HttpUrl url) {
    return new okhttp3.Request.Builder()
        .url(url)
        .addHeader(
            "Authorization", getBearerToken()
        );
  }


  /**
   * Execute the HTTP request, returning the response body as a String. If the request fails with
   * anything other than 409 (CONFLICT), then an {@link IllegalStateException} is thrown.
   */
  private static String executeRequest(@NonNull final Request request) {
    int CONFLICT = 409;
    OkHttpClient client = new OkHttpClient().newBuilder().build();
    try (Response response = client.newCall(request).execute()) {
      if (response.code() == CONFLICT) {
        log.warn("Entry already exists on the server: {}", request);
      } else if (!response.isSuccessful()) {
        String message = response + ((response.body()) == null ? "" : " :: " + response.body().string());
        throw new IllegalStateException(message);
      }
      return (response.body() == null) ? "" : response.body().string();
    } catch (IOException ex) {
      throw new IllegalStateException(ex);
    }
  }


  /**
   * Gets list of all users on the server. Returns data as a JSON string.
   */
  private static String getUsers() {
    HttpUrl url = buildUrl("admin/realms/" + realm + "/users");
    okhttp3.Request request = authorizedRequestBuilder(url).get().build();
    return executeRequest(request);
  }


  /**
   * Gets group membership of the given user. Returns data as a JSON string listing the groups.
   */
  private static String getGroupMembership(@NonNull final String userId) {
    HttpUrl url = buildAdminUrl("users/" + userId + "/groups");
    Request request = authorizedRequestBuilder(url).get().build();
    return executeRequest(request);
  }


  /**
   * Returns the given group's ID.
   */
  @SneakyThrows
  private static String getGroupId(@NonNull final String groupName) {
    HttpUrl url = new HttpUrl.Builder()
        .scheme("http")
        .host(hostname)
        .port(port)
        .addPathSegments("admin/realms/" + realm + "/groups")
        .addQueryParameter("search", groupName).build();
    Request request = authorizedRequestBuilder(url).get().build();
    JsonNode response = new ObjectMapper().readTree(executeRequest(request));
    assert response.size() == 1;
    return response.get(0).get("id").asText();
  }

  @SneakyThrows
  private static String getUserId(@NonNull final String username) {
    HttpUrl url = new HttpUrl.Builder()
        .scheme("http")
        .host(hostname)
        .port(port)
        .addPathSegments("admin/realms/" + realm + "/users")
        .addQueryParameter("search", username).build();
    Request request = authorizedRequestBuilder(url).get().build();
    JsonNode response = new ObjectMapper().readTree(executeRequest(request));
    assert response.size() == 1;
    return response.get(0).get("id").asText();
  }


  /**
   * Authenticate against the server and retrieve a bearer token.
   */
  private static String getBearerToken() {

    final String TOKEN_PATH = "realms/master/protocol/openid-connect/token";

    HttpUrl tokenUrl = buildUrl(TOKEN_PATH);

    FormBody formBody = new FormBody.Builder()
        .addEncoded("grant_type", "password")
        .addEncoded("client_id", "admin-cli")
        .addEncoded("username", username)
        .addEncoded("password", password)
        .build();

    Request tokenRequest = new Request.Builder()
        .url(tokenUrl)
        .method("POST", formBody)
        .addHeader("Content-Type", "application/x-www-form-urlencoded")
        .build();

    String response = executeRequest(tokenRequest);
    ObjectMapper objectMapper = new ObjectMapper();

    try {
      JsonNode node = objectMapper.readTree(response);
      if (!node.has("access_token")) {
        throw new IllegalStateException("Keycloak server did not return a token in the response");
      }
      return "Bearer " + node.get("access_token").asText();
    } catch (IOException ex) {
      throw new IllegalStateException("Problem occurred while getting token.", ex);
    }
  }


  /**
   * Simple utility class for loading resource files.
   */
  private static final class FileUtils {

    /**
     * Returns a {@link File} for an item in the test {@code resources} folder.
     */
    public static File getResourceFile(final String filename) {
      URL url = LoadKeycloakSampleData.class.getClassLoader().getResource(filename);
      if (url == null) {
        throw new IllegalStateException("Could not find resource file: " + filename);
      }
      try {
        File file = new File(url.toURI());
        if (!file.exists()) {
          throw new IllegalStateException("Could not find resource file: " + filename);
        }
        return file;
      } catch (URISyntaxException ex) {
        throw new IllegalStateException(ex);
      }
    }
  }


  @SneakyThrows
  private static void exportGroupMembership() {

    // Could have used this instead:
    // GET /admin/realms/{realm}/groups/{group-id}/members

    @AllArgsConstructor
    class GroupMember {

      public String userName;
      public String groupName;
    }

    // Record group membership
    List<GroupMember> groupMembers = new ArrayList<>();

    ObjectMapper objectMapper = new ObjectMapper();
    JsonNode users = objectMapper.readTree(getUsers());

    for (JsonNode user : users) {
      String userId = user.get("id").asText("");
      String username = user.get("username").asText();
      JsonNode groups = objectMapper.readTree(getGroupMembership(userId));
      for (JsonNode group : groups) {
        groupMembers.add(
            new GroupMember(username, group.get("name").asText())
        );
      }
    }

    // Export to JSON
    System.out.println(objectMapper.writeValueAsString(groupMembers));
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/ResponseConverterTest.java
================================================
package local.keycloak;

import static org.assertj.core.api.Assertions.assertThat;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.radiantlogic.iddm.base.Field;
import com.radiantlogic.iddm.base.Schema;
import com.radiantlogic.iddm.base.SearchResultEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import lombok.NonNull;
import lombok.SneakyThrows;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

class ResponseConverterTest {

  Set<SearchResultEntry> expectedData;

  Schema schema = TestData.schema;

  @BeforeEach
  void setUp() {

    expectedData = new HashSet<>();

    expectedData.add(
        new SearchResultEntry() {{
          put("id", "78abc9ce-6f92-46ad-a200-28c9f0495736");
          put("username", "gwbush");
          put("firstName", "George W.");
          put("lastName", "Bush");
          put("email", "gwbush@local");
          put("emailVerified", "true");
          put("enabled", "true");
          put("party", "Republican");
        }}
    );

    expectedData.add(
        new SearchResultEntry() {{
          put("id", "2978b015-7e6a-4101-add1-9b8edaddcc3e");
          put("username", "harris");
          put("firstName", "Kamala");
          put("lastName", "Harris");
          put("email", "harris@local");
          put("emailVerified", "true");
          put("enabled", "true");
        }}
    );
  }

  @Test
  @SneakyThrows
  void convertUsers() {

    // Given a response from /users
    String data = filterByUsernames("harris", "gwbush");

    // When converting the data to a response
    ResponseConverter converter = new ResponseConverter();
    List<SearchResultEntry> expectedResponse = new ArrayList<>(expectedData);

    // Then the returned data contain the expected attributes (though it may contain more or "extra")
    List<SearchResultEntry> actualResponse = converter.convert(data);
    String[] fieldsToCompare = schemaObjectFields("kc_users");
    assertThat(actualResponse).usingRecursiveComparison()
        .comparingOnlyFields(fieldsToCompare)
        .isEqualTo(expectedResponse);
  }

  /** Filters the {@link TestData#usersString} by username. Convenience for cleaner tests. */
  @SneakyThrows
  private String filterByUsernames(@NonNull final String username, String... otherUsers) {

    ObjectMapper objectMapper = new ObjectMapper();

    Set<String> filter = new HashSet<>();
    filter.add(username);
    if (otherUsers.length > 0) {
      filter.addAll(Arrays.asList(otherUsers));
    }

    List<JsonNode> toKeep = new ArrayList<>();
    JsonNode jsonNode = objectMapper.readTree(TestData.usersString);
    assert jsonNode.isArray() : "Documenting assumption";
    for (int i = 0; i < jsonNode.size(); i++) {
      String toFind = jsonNode.get(i).get("username").asText();
      if (filter.contains(toFind)) {
        toKeep.add(jsonNode.get(i));
      }
    }

    return objectMapper.writeValueAsString(toKeep);
  }

  /** Returns the names of fields in the given schema object. */
  private String[] schemaObjectFields(final String schemaObject) {
    return schema.getSchemaObject(schemaObject)
        .orElseThrow(() -> new AssertionError("Test setup failed"))
        .getFields().stream().map(Field::getName).toArray(String[]::new);
  }
}


================================================
FILE: iddm-sdk-custom-connector/src/test/java/local/keycloak/TestData.java
================================================
package local.keycloak;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.ImmutableList;
import com.radiantlogic.iddm.base.Field;
import com.radiantlogic.iddm.base.ReadOnlyProperties;
import com.radiantlogic.iddm.base.Schema;
import com.radiantlogic.iddm.base.SchemaObject;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;

public class TestData {

  public static final ReadOnlyProperties connectionProperties = ReadOnlyProperties.builder()
      .put("host", "localhost")
      .put("port", 8080)
      .put("username", "admin")
      .put("password", "admin")
      .put("realm", "iddm-sdk")
      .build();

  // https://www.keycloak.org/docs-api/latest/rest-api/index.html#UserRepresentation
  public static final SchemaObject userSchemaObject = SchemaObject.create("kc_users", "kcUser", "username", "username",
      ImmutableList.of(
          Field.builder().name("id").type(Field.Type.STRING).build(),
          Field.builder().name("username").type(Field.Type.STRING).build(),
          Field.builder().name("email").type(Field.Type.STRING).build(),
          Field.builder().name("firstName").type(Field.Type.STRING).build(),
          Field.builder().name("lastName").type(Field.Type.STRING).build(),
          Field.builder().name("emailVerified").type(Field.Type.BOOLEAN).build(),
          Field.builder().name("enabled").type(Field.Type.BOOLEAN).build(),
          Field.builder().name("party").type(Field.Type.STRING).tag("custom").build()
      )
  );

  // https://www.keycloak.org/docs-api/latest/rest-api/index.html#GroupRepresentation
  public static final SchemaObject groupSchemaObject = SchemaObject.create("kc_groups", "kcGroup", "name", "name",
      ImmutableList.of(
          Field.builder().name("id").type(Field.Type.STRING).build(),
          Field.builder().name("name").type(Field.Type.STRING).build(),
          Field.builder().name("member").type(Field.Type.STRING).build()
      )
  );

  public static final Schema schema = new Schema("keycloak",
      ImmutableList.of(userSchemaObject, groupSchemaObject));

  // Single view is associated with multiple schemas because the view hold multiple object types.
  //  This is a realistic use case. For example, having an OU by office location where the
  //  OU contains users and groups for that location.
  public static final ReadOnlyProperties views = ReadOnlyProperties.builder()
      .put("ou=whitehouse,o=executive", ImmutableList.of(
          userSchemaObject.getName(), groupSchemaObject.getName()
      )).build();

  public static final ReadOnlyProperties targetSchemaObjects = ReadOnlyProperties.builder()
      .put("schemaObjects", ImmutableList.of("kc_users", "kc_groups"))
      .build();


  public static final String usersString;

  static {
    try {
      usersString = readResourceFile("users.json").toString();
    } catch (IOException | URISyntaxException e) {
      throw new RuntimeException(e);
    }
  }

  public static final String groupsString;

  static {
    try {
      groupsString = readResourceFile("groups.json").toString();
    } catch (IOException | URISyntaxException e) {
      throw new RuntimeException(e);
    }
  }

  /** Returns a {@link File} for an item in the test {@code resources} folder. */
  private static File getResourceFile(final String filename) throws FileNotFoundException, URISyntaxException {
    URL url = TestData.class.getClassLoader().getResource(filename);
    if (url == null) {
      throw new FileNotFoundException("Could not find resource file: " + filename);
    }
    File file = new File(url.toURI());
    if (!file.exists()) {
      throw new FileNotFoundException("Could not find resource file: " + filename);
    }
    return file;
  }

  /** Loads the resource file's contents in a {@link JsonNode}. */
  private static JsonNode readResourceFile(final String filename) throws IOException, URISyntaxException {
    return new ObjectMapper().readTree(getResourceFile(filename));
  }
}



================================================
FILE: iddm-sdk-custom-connector/src/test/resources/groups.json
================================================
[
  {
    "name": "Presidents",
    "path": "/Presidents",
    "subGroupCount": 0,
    "subGroups": [],
    "access": {
      "view": true,
      "viewMembers": true,
      "manageMembers": true,
      "manage": true,
      "manageMembership": true
    }
  },
  {
    "name": "VPs",
    "path": "/VPs",
    "subGroupCount": 0,
    "subGroups": [],
    "access": {
      "view": true,
      "viewMembers": true,
      "manageMembers": true,
      "manage": true,
      "manageMembership": true
    }
  }
]


================================================
FILE: iddm-sdk-custom-connector/src/test/resources/membership.json
================================================
[
  {
    "username": "biden",
    "groupName": "Presidents"
  },
  {
    "username": "biden",
    "groupName": "VPs"
  },
  {
    "username": "bush",
    "groupName": "Presidents"
  },
  {
    "username": "bush",
    "groupName": "VPs"
  },
  {
    "username": "cheney",
    "groupName": "VPs"
  },
  {
    "username": "clinton",
    "groupName": "Presidents"
  },
  {
    "username": "gore",
    "groupName": "VPs"
  },
  {
    "username": "gwbush",
    "groupName": "Presidents"
  },
  {
    "username": "harris",
    "groupName": "VPs"
  },
  {
    "username": "obama",
    "groupName": "Presidents"
  },
  {
    "username": "pence",
    "groupName": "VPs"
  },
  {
    "username": "quayle",
    "groupName": "VPs"
  },
  {
    "username": "reagan",
    "groupName": "Presidents"
  },
  {
    "username": "trump",
    "groupName": "Presidents"
  },
  {
    "username": "vance",
    "groupName": "VPs"
  }
]



================================================
FILE: iddm-sdk-custom-connector/src/test/resources/users.json
================================================
[
  {
    "username": "biden",
    "firstName": "Joseph",
    "lastName": "Biden",
    "email": "jbiden@local",
    "emailVerified": true,
    "attributes": {
      "party": [
        "Democratic"
      ]
    },
    "createdTimestamp": 1737066784954,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "bush",
    "firstName": "George H. W.",
    "lastName": "Bush",
    "email": "ghwbush@local",
    "emailVerified": false,
    "attributes": {
      "party": [
        "Republican"
      ]
    },
    "createdTimestamp": 1737577267637,
    "enabled": false,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "cheney",
    "firstName": "Richard",
    "lastName": "Cheney",
    "email": "cheney@local",
    "emailVerified": false,
    "attributes": {
      "party": [
        "Republican"
      ]
    },
    "createdTimestamp": 1737067142295,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "clinton",
    "firstName": "William",
    "lastName": "Clinton",
    "email": "clinton@local",
    "emailVerified": true,
    "attributes": {
      "party": [
        "Democratic"
      ]
    },
    "createdTimestamp": 1737577177941,
    "enabled": false,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "gore",
    "firstName": "Albert",
    "lastName": "Gore",
    "email": "gore@local",
    "emailVerified": true,
    "attributes": {
      "party": [
        "Democratic"
      ]
    },
    "createdTimestamp": 1737577226880,
    "enabled": false,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "gwbush",
    "firstName": "George W.",
    "lastName": "Bush",
    "email": "gwbush@local",
    "emailVerified": true,
    "attributes": {
      "party": [
        "Republican"
      ]
    },
    "createdTimestamp": 1737066871450,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "harris",
    "firstName": "Kamala",
    "lastName": "Harris",
    "email": "harris@local",
    "emailVerified": true,
    "createdTimestamp": 1737066998587,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "obama",
    "firstName": "Barack",
    "lastName": "Obama",
    "email": "obama@local",
    "emailVerified": true,
    "createdTimestamp": 1737066834583,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "pence",
    "firstName": "Michael",
    "lastName": "Pence",
    "email": "pence@local",
    "emailVerified": true,
    "createdTimestamp": 1737067028872,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "quayle",
    "firstName": "Danforth",
    "lastName": "Quayle",
    "email": "quayle@local",
    "emailVerified": false,
    "createdTimestamp": 1737577359545,
    "enabled": false,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "reagan",
    "firstName": "Ronald",
    "lastName": "Reagan",
    "email": "reagan@local",
    "emailVerified": false,
    "createdTimestamp": 1737577401551,
    "enabled": false,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "trump",
    "firstName": "Donald",
    "lastName": "Trump",
    "email": "trump@local",
    "emailVerified": true,
    "createdTimestamp": 1737066765627,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  },
  {
    "username": "vance",
    "firstName": "James",
    "lastName": "Vance",
    "email": "vance@local",
    "emailVerified": false,
    "createdTimestamp": 1737577113438,
    "enabled": true,
    "totp": false,
    "disableableCredentialTypes": [],
    "requiredActions": [],
    "notBefore": 0,
    "access": {
      "manageGroupMembership": true,
      "view": true,
      "mapRoles": true,
      "impersonate": true,
      "manage": true
    }
  }
]


================================================
FILE: iddm-sdk-hello-world-connector/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>local.demo</groupId>
  <artifactId>iddm-sdk-hello-world-connector</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>jar</packaging>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>com.radiantlogic</groupId>
      <artifactId>iddm-sdk</artifactId>
      <version>8.1.3-alpha.1-SNAPSHOT</version>
      <!-- Do not include the IDDM-SDK in the fat JAR. It's unnecessary and can cause conflicts. -->
      <scope>provided</scope>
    </dependency>
  </dependencies>

</project>


================================================
FILE: iddm-sdk-hello-world-connector/src/main/java/local/demo/HelloWorldConnector.java
================================================
package local.demo;

import com.radiantlogic.iddm.annotations.CustomConnector;
import com.radiantlogic.iddm.base.AuthenticationOperations;
import com.radiantlogic.iddm.base.CreateOperations;
import com.radiantlogic.iddm.base.DeleteOperations;
import com.radiantlogic.iddm.base.LdapResponse;
import com.radiantlogic.iddm.base.LdapResultCode;
import com.radiantlogic.iddm.base.ModifyOperations;
import com.radiantlogic.iddm.base.ReadOperations;
import com.radiantlogic.iddm.base.Request;
import com.radiantlogic.iddm.base.Response;
import com.radiantlogic.iddm.base.SearchScope;
import com.radiantlogic.iddm.ldap.AddRequest;
import com.radiantlogic.iddm.ldap.BindRequest;
import com.radiantlogic.iddm.ldap.DeleteRequest;
import com.radiantlogic.iddm.ldap.ModifyRequest;
import com.radiantlogic.iddm.ldap.SearchRequest;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Simple "Hello World" connector.
 * <p>
 * This connector demonstrates the minimum requirements for being a valid SDK-based connector
 * that supports LDAP operations add, search, modify, delete, and bind.
 * <p>
 * To be simple as possible, this connector returns canned data for demonstration purposes. This
 * data cannot be modified through LDAP operations.
 */
@CustomConnector(metaJsonFile = "hello_world.json")
public class HelloWorldConnector implements
    CreateOperations<AddRequest, LdapResponse<String>>,
    ReadOperations<SearchRequest, LdapResponse<?>>,
    ModifyOperations<ModifyRequest, LdapResponse<String>>,
    DeleteOperations<DeleteRequest, LdapResponse<String>>,
    AuthenticationOperations<BindRequest, LdapResponse<String>> {

  /** Sample data returned by the connector. */
  private final List<Map<String, Object>> entries;

  /** Creates a new connector instance with canned data. */
  public HelloWorldConnector() {

    entries = new ArrayList<Map<String, Object>>() {{
      add(new HashMap<String, Object>() {{
        put("firstName", "George");
        put("lastName", "Washington");
        put("title", "President");
        put("politicalAffiliation", "Independent");
        put("termsServed", 2);
      }});
    }};
  }

  @Override
  public LdapResponse<String> authenticate(final BindRequest request) {
    return new LdapResponse<>(LdapResultCode.SUCCESS, "Successful bind");
  }

  @Override
  public LdapResponse<String> insert(final AddRequest request) {
    return new LdapResponse<>(LdapResultCode.SUCCESS,
        "Inserted entry " + request.getDn()
    );
  }

  @Override
  public LdapResponse<String> delete(final DeleteRequest request) {
    return new LdapResponse<>(LdapResultCode.SUCCESS,
        "Deleted entry " + request.getDn()
    );
  }

  @Override
  public LdapResponse<String> modify(final ModifyRequest request) {
    return new LdapResponse<>(LdapResultCode.SUCCESS,
        "Modified entry " + request.getDn());
  }

  @Override
  public LdapResponse<?> search(final SearchRequest request) {
    return (request.getSearchScope() == SearchScope.BASE) ?
        new LdapResponse<>(LdapResultCode.SUCCESS, entries.get(0)) :
        new LdapResponse<>(LdapResultCode.SUCCESS, entries);
  }

  @Override
  public Response connect(final Request request) {
    return new LdapResponse<>(LdapResultCode.SUCCESS, "Successfully connected to backend");
  }
}



================================================
FILE: iddm-sdk-hello-world-connector/src/main/resources/data.json
================================================
[
  {
    "username": "washington",
    "firstName": "George",
    "lastName": "Washington",
    "email": "washington@executive.gov",
    "politicalParty": "Federalist",
    "termsServed": 2
  },
  {
    "username": "jefferson",
    "firstName": "Thomas",
    "lastName": "Jefferson",
    "email": "jefferson@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "madison",
    "firstName": "James",
    "lastName": "Madison",
    "email": "madison@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "monroe",
    "firstName": "James",
    "lastName": "Monroe",
    "email": "monroe@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "jqadams",
    "firstName": "John Q.",
    "lastName": "Adams",
    "email": "jqadams@executive.gov",
    "politicalParty": "National Republican",
    "termsServed": 1
  },
  {
    "username": "jackson",
    "firstName": "Andrew",
    "lastName": "Jackson",
    "email": "jackson@executive.gov",
    "politicalParty": "Democratic",
    "termsServed": 2
  },
  {
    "username": "vanburen",
    "firstName": "Martin",
    "lastName": "Van Buren",
    "email": "vanburen@executive.gov",
    "politicalParty": "Democratic",
    "termsServed": 1
  },
  {
    "username": "harrison",
    "firstName": "William",
    "lastName": "Harrison",
    "email": "harrison@executive.gov",
    "politicalParty": "Whig",
    "termsServed": 1
  },
  {
    "username": "tyler",
    "firstName": "John",
    "lastName": "Tyler",
    "email": "tyler@executive.gov",
    "politicalParty": "Whig",
    "termsServed": 1
  }
]


================================================
FILE: iddm-sdk-hello-world-connector/src/main/resources/local/demo/hello_world.json
================================================
{
  "name": "Hello World",
  "description": "A Hello World implementation of an SDK-based connector.",
  "backendCategory": "custom",
  "userCreated": true,
  "icon": "",
  "isSchemaExtractable": false,
  "meta": [
    {
      "name": "sampleProperty",
      "description": "This is a sample property read from the connector JAR.",
      "sectionName": "Properties",
      "defaultValue": "Hello, world!",
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    }
  ]
}


================================================
FILE: iddm-sdk-tutorial/README.md
================================================
# Radiant Logic Connector SDK

The Connector SDK provides the resources for building custom connectors that enable communication between IDDM and
third-party, non-LDAP data sources.

## Getting the SDK

The Connector SDK is currently available in
the [Radiant Logic GitLab Maven package registry](https://gitlab.com/groups/radiant-logic-engineering/-/packages?orderBy=created_at&sort=desc&search[]=iddm-sdk).

The latest version can be added to Maven projects using the dependency:

```text
<dependency>
  <groupId>com.radiantlogic</groupId>
  <artifactId>iddm-sdk</artifactId>
  <!-- Always retrieves the latest available 8.1+ version -->
  <version>[8.1,)</version>
</dependency>
```

### Compatibility

- Java 8
- IDDM v8.1.4-beta-2 or higher.

## Learning the Connector SDK

This tutorial and sample project are provided to demonstrate the steps involved in building a real connector. The tutorial should be followed end-to-end, but it can also serve as a quick reference when building a new connector.

More comprehensive documentation is forthcoming.

### Get the sample project

----------------------------------------------------

For the tutorial, we will build a connector to an imaginary _PennAveIAM_ server that provides account services for American presidents. The connector will need to support LDAP search operations and use the provided `PennAveClient` for accessing the server's REST API. Each section ends with a valid connector that's usable by IDDM.

Get started by cloning the sample project and loading it as a Maven project in your IDE.

The project follows the [Maven Standard Directory Layout](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html) and includes a few of files to get started:

```text
└───sdk-tutorial
    ├───pom.xml
    ├───README.md
    ├───PennAveIAMDatasource.zip
    └───src
        ├───main
        │   ├───java
        |   |   └───local.demo
        |   |       └───PennAveClient.java
        │   └───resources
        |       ├───local.demo
        |       |    └───pennave_connector.json
        |       └───sample_data.json  
        └───test
            └───java
```

### Create a connector

----------------------------------------------------

Start by creating a new class called `PennAveConnector`:

```java
@CustomConnector(metaJsonFile = "pennave_connector.json")
public class PennAveConnector implements Connector {
  /* ...does nothing... */
}
```

There are two things to notice. First, `PennAveConnector` implements the `Connector` interface. This tells IDDM that `PennAveConnector` class is a connector. Second, the `@CustomConnector` annotation is added as a way to provide IDDM additional information about the connector and how to use it. (More on that later.)

It isn't much but this is a valid connector. It can be packaged into a JAR using Maven then used to create a custom datasource in IDDM. But because the connector doesn't yet support any operations, IDDM would return an LDAP error for all incoming requests.


### Support LDAP search

----------------------------------------------------

The first step to making the connector useful is updating it to support LDAP search. We do this by replacing `Connector` with `ReadOperations<SearchRequest, LdapResponse<String>>` in the class definition:

```java
@CustomConnector(metaJsonFile = "pennave_connector.json")
public class PennAveConnector
    implements ReadOperations<SearchRequest, LdapResponse<String>> {

  @Override
  public LdapResponse<String> search(SearchRequest searchRequest) {
    // TODO: Return something to IDDM when a search is performed 
  }
}
```

Implementing `ReadOperations<SearchRequest, LdapResponse<String>>` tells IDDM four things about `PennAveConnector`:

1. It is a connector because it implements `ReadOperations` which extends `Connector`
2. It supports LDAP search because it implements `ReadOperations`
3. It expects to receive search requests from IDDM as `SearchRequest` objects
4. It will return search results to IDDM as `LdapResponse<String>` objects

Adding `ReadOperations` requires the connector implement `search()`. This method will be called by IDDM whenever a search request is received. But we're not yet ready to actually search for anything, so we'll return an error indicating the search operation is unavailable:

```java
@Override
public LdapResponse<String> search(SearchRequest searchRequest) {
  return new LdapResponse<>(LdapResultCode.UNAVAILABLE);
}
```

The updated connector can now receive LDAP search requests from IDDM.

### Connect to the external service

----------------------------------------------------

A useful connector needs to actually connect to something, so let's update the connector to use the PennAveIAM REST service.

The `PennAveClient` class requires a hostname, username, and password to connect.  But these values aren't known until runtime, well after the connector is written and deployed, so the connector will use the `@Property` annotation to request that information from IDDM. 

Update `PennAveConnector` by adding the constructor:

```java
@CustomConnector(metaJsonFile = "pennave_connector.json")
public class PennAveConnector
    implements ReadOperations<SearchRequest, LdapResponse<String>> {
  
  // Single constructor that uses @Property annotation to request properties from IDDM
  public PennAveConnector(
      @Property(name = CUSTOM_DATASOURCE_PROPERTIES) ReadOnlyProperties connectionProperties) {
      // TODO: Use the property values provided by IDDM to create a PennAveClient
  }
}
```

Adding the `@Property` annotated constructor parameter tells IDDM to inject the `CUSTOM_DATASOURCE_PROPERTIES` property set when creating the constructor. This property set contains all the information needed to create the `PennAveClient` then open a connection: 

```java
@CustomConnector(metaJsonFile = "pennave_connector.json")
public class PennAveConnector
    implements ReadOperations<SearchRequest, LdapResponse<String>> {

  // Member variable reference to the PennAveClient created in the constructor
  private final PennAveClient pennAveClient;

  public PennAveConnector(
      @Property(name = CUSTOM_DATASOURCE_PROPERTIES) ReadOnlyProperties connectionProperties) {

    // Read individual properties provided by IDDM 
    String host = (String) connectionProperties.get("host");
    String username = (String) connectionProperties.get("username");
    String password = (String) connectionProperties.get("password");

    // Create an instance of the REST client and connect
    this.pennAveClient = new PennAveClient(host, username, password);
    this.pennAveClient.connect();
  }
}
```

It's reasonable to wonder where the individual properties come from: they're all defined in the `pennave_connector.json`. But more on that later.

The connector now has everything it needs to query the PennAveIAM server.

### Returning data

----------------------------------------------------

It's time to return some actual search results.

To start, the connector will return all users whenever it receives any search request. It'll do this by calling `PennAveClient.getAllUsers()`. This method gets all the users from the PennAveIAM server and returns the data as a raw JSON string (or `null` if the request fails):

```json 
[
  {
    "username": "washington",
    "firstName": "George",
    "lastName": "Washington",
    "email": "washington@executive.gov",
    "politicalParty": "Federalist",
    "termsServed": 2
  },
  ...
]
```

Update the `PennAveConnector.search()` method to get the user data then include it in the `LdapResponse`:

```java
@Override
public LdapResponse<String> search(SearchRequest searchRequest) {

  // Get user data from the PennAveIAM server
  String jsonResponse = pennAveClient.getAllUsers();
  
  // Return a successful response only if there search results
  return jsonResponse != null ?
    // Include the data in the response to IDDM
    new LdapResponse<>(LdapResultCode.SUCCESS, jsonResponse) :
    new LdapResponse<>(LdapResultCode.OPERATIONS_ERROR);
}

```

Notice the JSON string is placed directly in the `LdapResponse` without any additional processing. This works because IDDM automatically converts the connector response into an LDAP appropriate format. It will even apply any required post-processing, such as virtual attribute mapping and DN customization, so that the connector doesn't need to worry about it.

The connector now returns real data to IDDM.

### Refine the search process

----------------------------------------------------

The connector began supporting search operations as soon as it implemented the `ReadOperations` interface. But so far, it has completely ignored the actual request and returned only generic responses. Let's change that. If the connector receives a base scope search, then it should return only the user identified in the request's base DN. In all other cases, the connector should return all users.

Implementing this behavior requires inspecting the `SearchRequest` argument. Start by updating `PennAveConnector.search()` to take a different action based on the search scope:

```java
@Override
public LdapResponse<String> search(SearchRequest searchRequest) {

    String jsonResponse = null;
    if (searchRequest.getSearchScope() == SearchScope.BASE) {
      // TODO: 
      //  1. Extract the username from the search request
      //  2. Search the PennAveIAM server for the specific user
    } else {
      jsonResponse = pennAveClient.getAllUsers();
    }
    
    return jsonResponse != null ?
        new LdapResponse<>(LdapResultCode.SUCCESS, jsonResponse) :
        new LdapResponse<>(LdapResultCode.OPERATIONS_ERROR);
}
```

Next, add the `getUsername()` method for extracting the username from the base DN:

```java
private String getUsername(SearchRequest searchRequest) {
  // Get the base DN from the search request. Ex: "username=washington,o=pennaveiam"
  DN dn = searchRequest.getBaseDN();
  // Split the DN into its individual components. Ex: ["username=washington", "o=pennaveiam"]
  List<RDN> components = dn.getRDNs();
  // Retrieve the left-most RDN. Ex: "username=washington"
  RDN rdn = components.get(0);
  // Retrieve username. Ex: "washington"
  return rdn.getAttributeValue();
}
```

Finally, update `search()` to get the user from the PennAveIAM server:

```java
@Override
public LdapResponse<String> search(SearchRequest searchRequest) {
  
    String jsonResponse = null;
    if (searchRequest.getSearchScope() == SearchScope.BASE) {
      // Extract the username from the incoming search request
      String username = getUsername(searchRequest);
      // Search the PennAveIAM server for the specific user  
      jsonResponse = pennAveClient.getUser(username);
    } else {
      jsonResponse = pennAveClient.getAllUsers();
    }

    return jsonResponse != null ?
        new LdapResponse<>(LdapResultCode.SUCCESS, jsonResponse) :
        new LdapResponse<>(LdapResultCode.OPERATIONS_ERROR);
}
```

The connector now supports getting all users and specific users.

### Describe the connector

----------------------------------------------------

With the required search functionality implemented, let's prepare the connector for deployment by updating the metadata file.

The connector metadata is a JSON formatted file with two important roles. First, it provides information to IDDM about how to present the connector to IDDM users: what is it called, what icon should it use, etc. Second, it provides the developer a place to define custom configuration properties that IDDM users will set when using the connector. (These are the values IDDM provides when using the `@Property(name = CUSTOM_DATASOURCE_PROPERTIES)` annotation.)

Open _pennave_connector.json_ then replace the `name` and `description` with more descriptive values:

```json
{
  "name": "PennAveIAM",
  "description": "Sample connector created using the Connector SDK tutorial",
  ...
```

Next, update the `meta` JSON array (in _pennave_connector.json_) by setting `"isRequired": true` for all three custom properties: host, username, and password. This guarantees the properties will be set by the IDDM user and available to the connector:

```json
{
  ...
  "meta": [
    {
      "name": "host",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": true,
      "regex": null
    },
    {
      "name": "username",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": true,
      "regex": null
    },
    {
      "name": "password",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": "",
      "dataType": "PASSWORD",
      "isRequired": true,
      "regex": null
    }
  ]
}

```

The connector now includes information to help users understand and configure it in the IDDM Control Panel.

### Package the connector

----------------------------------------------------

Now that the connector is fully implemented, we can package it for IDDM to use. This requires creating a JAR that includes the connector code and any external dependencies (such as Google Guava or Apache Commons libraries) because IDDM does not provide dependency management. We can do this by executing the Maven goals `clean` and `package` from either the IDE or terminal:

```text
$ mvn clean package
```

This will produce two JARs in the project's `target` directory: _pennaveiam-connector.jar_ and _pennaveiam-connector-jar-with-dependencies.jar_. The _pennaveiam-connector-jar-with-dependencies.jar_ is the one we want; this is the JAR that will be loaded into IDDM.

### Deploy to IDDM

----------------------------------------------------

With _pennave-connector-jar-with-dependencies.jar_ built and ready to use, follow the [IDDM documentation for creating a new template](https://developer.radiantlogic.com/idm/v8.1/configuration/data-sources/data-sources/#creating-templates). This will walk you through loading the connector into IDDM. However, one notable difference is there will be no need to fill-in details about the connector because IDDM automatically loads this information from the metadata file.

Once the JAR is loaded and a new template created, the connector is ready for use in IDDM. To try it out, import the _PennAveIAMDatasource.zip_ datasource provided in this tutorial by following the [IDDM documentation for importing data sources](https://developer.radiantlogic.com/idm/v8.1/configuration/data-sources/data-sources/#importing-data-sources) then create a new naming context to browse the data.


================================================
FILE: iddm-sdk-tutorial/PennAveIAMDatasource.zip
================================================
[Non-text file]


================================================
FILE: iddm-sdk-tutorial/pom.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>local.demo</groupId>
  <artifactId>pennaveiam-connector</artifactId>
  <packaging>jar</packaging>
  <version>1.0</version>

  <properties>
    <maven.compiler.source>8</maven.compiler.source>
    <maven.compiler.target>8</maven.compiler.target>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>com.radiantlogic</groupId>
      <artifactId>iddm-sdk</artifactId>
      <version>[8.1,)</version>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.fasterxml.jackson.core</groupId>
      <artifactId>jackson-databind</artifactId>
      <version>2.17.2</version>
    </dependency>
  </dependencies>

  <build>
    <finalName>pennaveiam-connector</finalName>
    <pluginManagement>
      <plugins>
        <plugin>
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-compiler-plugin</artifactId>
          <version>2.3.1</version>
          <configuration>
            <source>1.8</source>
            <target>1.8</target>
          </configuration>
        </plugin>
      </plugins>
    </pluginManagement>
    <plugins>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
    </plugins>
  </build>


</project>


================================================
FILE: iddm-sdk-tutorial/src/main/java/local/demo/PennAveClient.java
================================================
package local.demo;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.io.InputStream;
import javax.annotation.Nullable;
import org.apache.commons.lang3.StringUtils;

public class PennAveClient {

  private static final String DATA_FILE = "sample_data.json";

  private static final String HOST = "api.pennaveiam.local";

  private static final String USERNAME = "admin";

  private static final String PASSWORD = "Password1";

  private boolean connected = false;

  private final String host;

  private final String username;

  private final String password;


  public PennAveClient(String host, String username, String password) {
    this.host = host;
    this.username = username;
    this.password = password;
  }

  public void connect() {
    if (!StringUtils.equals(host, HOST)) {
      throw new IllegalArgumentException("Unknown host");
    }
    if (!StringUtils.equals(username, USERNAME)) {
      throw new IllegalArgumentException("Invalid username");
    }
    if (!StringUtils.equals(password, PASSWORD)) {
      throw new IllegalArgumentException("Invalid password");
    }

    connected = true;
  }

  public String getAllUsers() {
    return loadData().toString();
  }

  public @Nullable String getUser(final String username) {
    assert StringUtils.isNotBlank(username);
    JsonNode users = loadData();
    for (JsonNode user : users) {
      if (StringUtils.equalsIgnoreCase(username, user.get("username").asText(StringUtils.EMPTY))) {
        return user.toString();
      }
    }
    return null;
  }

  private JsonNode loadData() {
    if (!connected) {
      throw new IllegalStateException("Not connected");
    }

    try (InputStream inputStream = PennAveClient.class.getClassLoader().getResourceAsStream(DATA_FILE)) {
      return new ObjectMapper().readTree(inputStream);
    } catch (IOException ex) {
      throw new IllegalStateException("Failed to load sample data.");
    }
  }
}



================================================
FILE: iddm-sdk-tutorial/src/main/resources/sample_data.json
================================================
[
  {
    "username": "washington",
    "firstName": "George",
    "lastName": "Washington",
    "email": "washington@executive.gov",
    "politicalParty": "Federalist",
    "termsServed": 2
  },
  {
    "username": "jefferson",
    "firstName": "Thomas",
    "lastName": "Jefferson",
    "email": "jefferson@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "madison",
    "firstName": "James",
    "lastName": "Madison",
    "email": "madison@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "monroe",
    "firstName": "James",
    "lastName": "Monroe",
    "email": "monroe@executive.gov",
    "politicalParty": "Democratic-Republican",
    "termsServed": 2
  },
  {
    "username": "jqadams",
    "firstName": "John Q.",
    "lastName": "Adams",
    "email": "jqadams@executive.gov",
    "politicalParty": "National Republican",
    "termsServed": 1
  },
  {
    "username": "jackson",
    "firstName": "Andrew",
    "lastName": "Jackson",
    "email": "jackson@executive.gov",
    "politicalParty": "Democratic",
    "termsServed": 2
  },
  {
    "username": "vanburen",
    "firstName": "Martin",
    "lastName": "Van Buren",
    "email": "vanburen@executive.gov",
    "politicalParty": "Democratic",
    "termsServed": 1
  },
  {
    "username": "harrison",
    "firstName": "William",
    "lastName": "Harrison",
    "email": "harrison@executive.gov",
    "politicalParty": "Whig",
    "termsServed": 1
  },
  {
    "username": "tyler",
    "firstName": "John",
    "lastName": "Tyler",
    "email": "tyler@executive.gov",
    "politicalParty": "Whig",
    "termsServed": 1
  }
]


================================================
FILE: iddm-sdk-tutorial/src/main/resources/local/demo/pennave_connector.json
================================================
{
  "name": "<REPLACE ME -- NAME DISPLAYED IN THE IDDM CONTROL PANEL>",
  "description": "<REPLACE ME -- DESCRIPTION OF THE CONNECTOR>",
  "backendCategory": "custom",
  "userCreated": true,
  "icon": "",
  "isSchemaExtractable": false,
  "meta": [
    {
      "name": "host",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "username",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": null,
      "dataType": "STRING",
      "isRequired": false,
      "regex": null
    },
    {
      "name": "password",
      "description": null,
      "sectionName": "Properties",
      "defaultValue": "",
      "dataType": "PASSWORD",
      "isRequired": false,
      "regex": null
    }
  ]
}


================================================
FILE: src/main/java/com/radiantlogic/iddm/DN.java
================================================
package com.radiantlogic.iddm;

import com.unboundid.ldap.sdk.LDAPException;
import com.unboundid.util.NotNull;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

/**
 * This class provides a data structure for holding an LDAP distinguished name.
 *
 * <p>Strict compliance with RFC 4514 is not enforced. This makes it possible for some technically
 * invalid characters to be accepted in attribute type names. Additionally, distinguished names
 * constructed from zero-length and whitespace-only strings are considered equivalent.
 *
 * <p>
 *
 * <p>See <a href="http://www.ietf.org/rfc/rfc4514.txt">RFC 4514</A> for more information.
 */
@EqualsAndHashCode
@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public class DN {

  @NotNull private final com.unboundid.ldap.sdk.DN dn;

  /**
   * Create a new {@code DN} from the given string.
   *
   * <p>If the {@code dn} argument consists of only whitespace, then it is converted to a
   * zero-length string. In practice, this means {@code DN.from("").equals(DN.from(" ")} is {@code
   * true}.
   */
  public static DN from(@NonNull final String dn) {
    final boolean USE_STRICT_NAME_CHECKING = false;
    try {
      return new DN(new com.unboundid.ldap.sdk.DN(dn, null, USE_STRICT_NAME_CHECKING));
    } catch (LDAPException ex) {
      throw new IllegalArgumentException(ex.getExceptionMessage());
    }
  }

  public List<RDN> getRDNs() {
    return Stream.of(dn.getRDNs())
        .map(rdn -> RDN.from(rdn.toString()))
        .collect(Collectors.toList());
  }

  @Override
  public String toString() {
    return this.dn.toString();
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/lombok.config
================================================
# Configure @NonNull annotation to throw IllegalArgumentException instead of NullPointerException
lombok.nonNull.exceptionType=IllegalArgumentException


================================================
FILE: src/main/java/com/radiantlogic/iddm/Modification.java
================================================
package com.radiantlogic.iddm;

import javax.naming.directory.Attribute;
import javax.naming.directory.DirContext;
import javax.naming.directory.ModificationItem;
import lombok.NonNull;

/**
 * This class provides a data structure for describing LDAP modification request, including the
 * modification type, the name of the attribute to be modified, and the new attribute value.
 */
public final class Modification {

  private final ModificationItem modificationItem;

  private Modification(int modOperation, @NonNull Attribute attribute) {
    this.modificationItem = new ModificationItem(modOperation, attribute);
  }

  /** Returns the attribute to be modified. */
  public Attribute getAttribute() {
    return modificationItem.getAttribute();
  }

  /**
   * Returns an integer indicating the type of modification requested. The returned value maps to
   * the values found in {@link DirContext}.
   */
  public int getModificationType() {
    return modificationItem.getModificationOp();
  }

  /** Returns a {@link Modification} for adding a new attribute value. */
  public static Modification addAttribute(@NonNull final Attribute attribute) {
    return new Modification(DirContext.ADD_ATTRIBUTE, attribute);
  }

  /** Returns a {@link Modification} for replacing an existing attribute's value. */
  public static Modification replaceAttribute(@NonNull final Attribute attribute) {
    return new Modification(DirContext.REPLACE_ATTRIBUTE, attribute);
  }

  /** Returns a {@link Modification} for removing an existing attribute. */
  public static Modification removeAttribute(@NonNull final Attribute attribute) {
    return new Modification(DirContext.REMOVE_ATTRIBUTE, attribute);
  }

  /**
   * Returns a new {@link Modification} created using values from the {@link ModificationItem}
   * argument.
   */
  public static Modification from(@NonNull final ModificationItem modificationItem) {
    return new Modification(modificationItem.getModificationOp(), modificationItem.getAttribute());
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/RDN.java
================================================
package com.radiantlogic.iddm;

import com.unboundid.ldap.sdk.LDAPException;
import lombok.AccessLevel;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;
import org.apache.commons.lang3.StringUtils;

@RequiredArgsConstructor(access = AccessLevel.PRIVATE)
public final class RDN {

  @NonNull private final com.unboundid.ldap.sdk.RDN rdn;

  public static RDN from(@NonNull final String rdnString) {
    try {
      return new RDN(new com.unboundid.ldap.sdk.RDN(rdnString));
    } catch (LDAPException ex) {
      throw new IllegalArgumentException(ex.getExceptionMessage(), ex);
    }
  }

  /**
   * Returns a string concatenation of the attribute names, which appear on the left-side of the
   * RDN's equal sign.
   */
  public String getAttributeName() {
    return StringUtils.join(rdn.getAttributeNames());
  }

  /**
   * Returns a string concatenation of the attribute values, which appear on the right-side of the
   * RDN's equal sign.
   */
  public String getAttributeValue() {
    return StringUtils.join(rdn.getAttributeValues());
  }

  /**
   * Returns a non-normalized, non-encoded string representation of the RDN. For example, {@code
   * cn=Johnny Utah}.
   */
  @Override
  public String toString() {
    return rdn.toString();
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ResponseEntity.java
================================================
package com.radiantlogic.iddm;

import com.radiantlogic.iddm.base.Response;
import com.radiantlogic.iddm.base.StatusCode;
import javax.annotation.Nullable;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/**
 * Generic data structure for storing arbitrary data returned from third party backends. Uses
 * generics to allow the caller to store arbitrary data types while still providing IDDM and the SDK
 * a standard way to access that data and move it through the system.
 */
@EqualsAndHashCode
@Getter
@ToString
public class ResponseEntity<T> implements Response {

  protected final T data;

  protected final StatusCode status;

  public ResponseEntity(@NonNull final StatusCode status) {
    this.status = status;
    this.data = null;
  }

  public ResponseEntity(@NonNull final StatusCode status, @Nullable final T data) {
    this.data = data;
    this.status = status;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/SearchFilter.java
================================================
package com.radiantlogic.iddm;

import static com.radiantlogic.iddm.ValidationUtils.requireArgument;

import com.unboundid.ldap.sdk.Filter;
import com.unboundid.ldap.sdk.LDAPException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javax.annotation.Nullable;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

/** Class for representing an LDAP search filter. */
@Getter(AccessLevel.PRIVATE)
@AllArgsConstructor
public class SearchFilter {

  /** Enum describing the different filter operations supported by the enclosing class. */
  public enum Type {
    AND((byte) 0xA0),
    OR((byte) 0xA1),
    EQUAL((byte) 0xA3),
    PRESENCE((byte) 0x87);

    private final byte value;

    /** Mapping of byte values to Type enums. */
    private static final Map<Byte, Type> mapping =
        Stream.of(values()).collect(Collectors.toMap(type -> type.value, type -> type));

    Type(byte value) {
      this.value = value;
    }

    static Type fromBytes(byte value) {
      return ValidationUtils.requireNonNull(
          mapping.get(value), String.format("Unknown %s type for %b", Type.class.getName(), value));
    }
  }

  /** Internal, wrapped UnboundID representation of the filter. */
  private final Filter filter;

  /** Returns a {@code SearchFilter} representation of the {@code filterString}. */
  public static @NonNull SearchFilter from(String filterString) {
    requireArgument(
        StringUtils.isNotBlank(filterString),
        String.format(
            "Unable to create a %s from an empty string.", SearchFilter.class.getSimpleName()));

    try {
      return new SearchFilter(Filter.create(filterString));
    } catch (LDAPException ex) {
      // TODO (M.Silva, 18jan2024) - throw an appropriate exception type
      throw new IllegalArgumentException(
          String.format(
              "Failed to parse filter string when creating a new %s",
              SearchFilter.class.getSimpleName()));
    }
  }

  public @NonNull Type getType() {
    return Type.fromBytes(filter.getFilterType());
  }

  /** Returns {@code true} if the filter is a conditional AND or OR filter. */
  public boolean isConditional() {
    return filter.getFilterType() == Type.AND.value || filter.getFilterType() == Type.OR.value;
  }

  /**
   * Returns list of individual {@code SearchFilter} objects that make up {@code this} filter if
   * {@link SearchFilter#isConditional()} is {@code true}. Otherwise, returns an empty list.
   */
  public List<SearchFilter> getComponents() {
    // TODO (M.Silva, 19Jan2025) - Make sure this isn't leaking UnboundID.Filter objects
    return Stream.of(filter.getComponents())
        .map(condition -> SearchFilter.from(condition.toString()))
        .collect(Collectors.toList());
  }

  public String toString() {
    return this.filter.toString();
  }

  public @NonNull String getValue() {
    return filter.getAssertionValue() == null ? "*" : filter.getAssertionValue();
  }

  public @NonNull String getAttribute() {
    return filter.getAttributeName();
  }

  @Override
  public boolean equals(@Nullable final Object otherFilter) {
    if (!(otherFilter instanceof SearchFilter)) {
      return false;
    }
    SearchFilter otherSearchFilter = (SearchFilter) otherFilter;
    return this.filter.equals(otherSearchFilter.getFilter());
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ValidationUtils.java
================================================
package com.radiantlogic.iddm;

import com.google.common.base.Strings;
import com.google.common.collect.Lists;
import java.util.List;
import java.util.Objects;
import javax.annotation.Nullable;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

/** Utility class with methods for validating method arguments. */
public final class ValidationUtils {

  private ValidationUtils() {}

  /** Throws {@link IllegalArgumentException} if any string is blank. */
  @Deprecated
  public static void requireNotBlank(String str, String... additionalStrs) {
    List<String> toValidate = Lists.asList(str, additionalStrs);
    for (String value : toValidate) {
      if (StringUtils.isBlank(value)) {
        fail(
            IllegalArgumentException.class,
            "Value cannot be blank."); // TODO: Replace placeholder error message
      }
    }
  }

  /**
   * Confirms the {@code str} is not empty (""), not null, and not whitespace only, throwing an
   * {@link IllegalStateException} if any condition fails.
   *
   * @return the validated str for convenience.
   */
  @Deprecated
  public static String requireNotBlank(@Nullable String str, @NonNull String message) {
    if (StringUtils.isBlank(str)) {
      fail(IllegalStateException.class, message);
    }
    return str;
  }

  @Deprecated
  public static void requireNonNull(Object obj, Object... additionalObjects) {
    List<Object> toValidate = Lists.asList(obj, additionalObjects);
    for (Object value : toValidate) {
      if (Objects.isNull(value)) {
        fail(
            IllegalArgumentException.class,
            "Value cannot be null"); // TODO: Replace placeholder error message.
      }
    }
  }

  /** Throws {@link NullPointerException} with the given message. Returns the object if not null. */
  @SuppressWarnings("unchecked")
  public static <T> T requireNonNull(@Nullable Object obj, @NonNull String message) {
    return (T) Objects.requireNonNull(obj, message);
  }

  /**
   * Confirms the {@code stateCondition} is true. Otherwise, throws a {@link IllegalStateException}
   * with the given message and params.
   *
   * <p>This method is intended for indicating when the <em>caller</em> has a made a mistake by
   * calling an object's method before some precondition is met (e.g., trying to use an object
   * before it is instantiated) and using different method arguments would not have worked.
   */
  public static void requireState(final boolean stateCondition, String message, String... params) {
    if (!stateCondition) {
      throw new IllegalStateException(formatMessage(message, params));
    }
  }

  /**
   * Confirms the {@code argumentCondition} is true. Otherwise, throws a {@link
   * IllegalArgumentException} with the given message and params.
   */
  public static void requireArgument(
      final boolean argumentCondition, String message, String... params) {
    if (!argumentCondition) {
      throw new IllegalArgumentException(formatMessage(message, params));
    }
  }

  /**
   * Checks if the {@code object} can be assigned to a variable of type {@code cls}. Returns {@code
   * object} cast as type {@code T} if valid; throw {@link ClassCastException} otherwise.
   *
   * @implNote This is a convenience method that wraps {@link Class#isAssignableFrom(Class)}.
   */
  @SuppressWarnings("unchecked")
  public static <T> T requireType(Object object, Class<T> cls, String message) {
    if (!cls.isAssignableFrom(object.getClass())) {
      throw new ClassCastException(message);
    }
    return (T) object;
  }

  /**
   * Used for validating arguments.
   *
   * <p>Checks if {@code thisArgument} can be assigned to a variable of type {@code ofType}. Returns
   * {@code thisArgument} cast as type {@code T} if valid; throws {@link IllegalArgumentException}
   * otherwise.
   *
   * @implNote This is effectively a convenience method that wraps {@link
   *     Class#isAssignableFrom(Class)}.
   */
  @SuppressWarnings("unchecked")
  public static <T> T requireArgument(Object thisArgument, Class<T> ofType, String message) {
    if (!ofType.isAssignableFrom(thisArgument.getClass())) {
      throw new IllegalArgumentException(message);
    }
    return (T) thisArgument;
  }

  private static void fail(Class<?> exceptionType, String message) {

    RuntimeException toThrow;

    if (exceptionType == IllegalArgumentException.class) {
      toThrow = new IllegalArgumentException(message);
    } else {
      toThrow = new IllegalStateException(message);
    }

    throw toThrow;
  }

  /**
   * Returns the given template string with each occurrence of "%s" replaced with the corresponding
   * argument value from args.
   *
   * <p>This method uses Guava's {@link Strings#lenientFormat(String, Object...)} to create the
   * error message but produces slightly different behavior. It's intended use is best explained by
   * the {@code Strings#lenientFormat} method documentation:
   *
   * <blockquote>
   *
   * For most string-formatting needs, use String.format, PrintWriter.format, and related methods.
   * These support the full range of format specifiers, and alert you to usage errors by throwing
   * IllegalFormatException. In certain cases, such as outputting debugging information or
   * constructing a message to be used for another unchecked exception, an exception during string
   * formatting would serve little purpose except to supplant the real information you were trying
   * to provide. These are the cases this method is made for; it instead generates a best-effort
   * string with all supplied argument values present.
   *
   * </blockquote>
   */
  static String formatMessage(@NonNull final String template, String... args) {

    return (args == null || args.length == 0)
        ? Strings.lenientFormat(template)
        : Strings.lenientFormat(template, (Object[]) args);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/annotations/CustomConnector.java
================================================
package com.radiantlogic.iddm.annotations;

import com.radiantlogic.iddm.base.TypeConverter;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Requirements: - Annotated class must have only constructor - Constructor must be 0 args OR all
 * parameters must be marked with @ManagedComponent or @Property
 *
 * <p>The adapter parameters are used to ensure IDDM know exactly which adapter to use with which
 * connector, even the event that multiple classes implement the adapter interfaces.
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface CustomConnector {
  // TODO API-2542: Finalize field name decision (this shouldn't specifically mention "meta", "JSON"
  // or "file" but haven't agreed on better ideas yet)
  /**
   * This value tells IDDM where to find the JSON file describing this connector.
   *
   * @return The path of a JSON file visible as a resource to this class
   */
  String metaJsonFile();

  Class<? extends TypeConverter>[] typeConverters() default {};
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/annotations/ManagedComponent.java
================================================
package com.radiantlogic.iddm.annotations;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Marked as {@code @Inherited} to make it easier for customers. The annotation can be applied to
 * SDK classes that represent managed components (such as interfaces and abstract classes). When the
 * customer implements or extends those classes, the @ManagedComponent annotation is automatically
 * applied so the customer doesn't need to worry about doing it. Requirements: - 0 arg constructor
 * OR all args have @Property annotation
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ManagedComponent {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/annotations/Property.java
================================================
package com.radiantlogic.iddm.annotations;

import com.radiantlogic.iddm.base.InjectableProperties;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Property {

  InjectableProperties name();
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/AuthenticationOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform authentication operations against
 * the back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided). For example:
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements AuthenticationOperations<CustomLoginRequest, LoginResponse>
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface AuthenticationOperations<IN extends Request, OUT extends Response>
    extends Connector {

  /**
   * Performs an authentication operation against the backend.
   *
   * @param request describing the authentication to perform.
   * @return the operation result, including status and any data returned by the backend.
   */
  OUT authenticate(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/AuthenticationRequest.java
================================================
package com.radiantlogic.iddm.base;

/** Represents a request for authentication. */
public interface AuthenticationRequest {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/AuthenticationResponse.java
================================================
package com.radiantlogic.iddm.base;

/** Represents the result of an authentication operation. */
public interface AuthenticationResponse {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ConnectionConfiguration.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for getting information about a connection.
 *
 * <p>This interface should be treated as read-only.
 */
@Deprecated
public interface ConnectionConfiguration {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ConnectionRequest.java
================================================
package com.radiantlogic.iddm.base;

import lombok.NonNull;

/** This class represents a request to connect to a URI identified resource. */
public interface ConnectionRequest extends Request {

  /** Returns the URI identifying the target of the connection request. */
  @NonNull
  Uri getTarget();
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ConnectionResponse.java
================================================
package com.radiantlogic.iddm.base;

import lombok.NonNull;

/** This class represents the result of attempting to connect to a URI identified resource. */
public interface ConnectionResponse extends Response {

  /** Returns the URI identifying the target of the connection response. */
  @NonNull
  Uri getTarget();
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Connector.java
================================================
package com.radiantlogic.iddm.base;

/**
 * An interface for marking custom connector implementations.
 *
 * <p>This class is intended for {@code radiantlogic.iddm} use only. It should not be used directly.
 * Instead, developers should use one of its child interfaces such as {@link ReadOperations}.
 */
public interface Connector {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/CreateOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform create/insert operations against
 * the back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided). For example:
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements CreateOperations<AddRequest, AddResponse>
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface CreateOperations<IN extends Request, OUT extends Response> extends Connector {

  /**
   * Performs an insert (create) operation against the backend.
   *
   * @param request describing the insert to perform.
   * @return the insert result, including status and any data returned by the backend.
   */
  OUT insert(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/DeleteOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform delete operations against the
 * back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided). For example:
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements DeleteOperations<DeleteRequest, DeleteResponse>
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface DeleteOperations<IN extends Request, OUT extends Response> extends Connector {

  /**
   * Performs a delete operation against the backend.
   *
   * @param request describing the deletion to perform.
   * @return the deletion result, including status and any data returned by the backend.
   */
  OUT delete(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ExtractSchemaOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform automatic schema extraction
 * operations against the back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided). For example:
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements ExtractSchemaOperations<SchemaRequest, SchemaResponse>
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface ExtractSchemaOperations<IN extends Request, OUT extends Response>
    extends Connector {

  /**
   * Performs a schema extract operation against the backend.
   *
   * @param request describing the extraction to perform.
   * @return the operation result, including status and any data returned by the backend.
   */
  OUT extract(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Field.java
================================================
package com.radiantlogic.iddm.base;

import static java.util.stream.Collectors.toMap;

import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Stream;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.Singular;
import org.apache.commons.lang3.StringUtils;

/**
 * See {@link SchemaObject} for description.
 *
 * <p>TODO (17 Jan. 2025) - Add property constraint validation.
 */
@Getter
@Builder
@AllArgsConstructor
public class Field {

  public static enum
      Type { // TODO (M.Silva, 27Jan2025) - Explicitly declared static to aid IntelliJ in debugging.
    BOOLEAN("BOOLEAN"),
    BINARY("BINARY"),
    STRING("VARCHAR"),
    INTEGER("INTEGER"),
    REAL("REAL"),
    NUMERIC("NUMERIC"),
    SMALLINT("SMALLINT"),
    TIMESTAMP("TIMESTAMP"),
    BLOB("BLOB"),
    CHAR("CHAR");

    /** Internal map of Strings to Types. */
    private static final Map<String, Type> stringToEnum =
        Stream.of(values()).collect(toMap(Object::toString, e -> e));

    private final String name;

    Type(String name) {
      this.name = name;
    }

    @Override
    public String toString() {
      return this.name;
    }

    public static Optional<Type> fromString(@NonNull final String symbol) {
      Type toReturn = stringToEnum.getOrDefault(symbol.toUpperCase(), null);
      if (toReturn != null) {
        return Optional.of(toReturn);
      }

      // Process parameterized data types (e.g., VARCHAR(255), BLOB(123456))
      return Optional.ofNullable(
          stringToEnum.getOrDefault(StringUtils.substringBefore(symbol, "("), null));
    }
  }

  /** Name of the field. This name should match the "Attribute Name" as it appears in IDDM. */
  private final String name;

  /** Custom attribute name that is exposed by IDDM to LDAP clients. */
  private final String mappedAttrName;

  /** Optional tags that can be added for additional processing by the connector. */
  @Singular private Set<String> tags;

  private final boolean nullable;

  private final Type type;
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/InjectableProperties.java
================================================
package com.radiantlogic.iddm.base;

import com.google.common.annotations.Beta;
import com.radiantlogic.iddm.annotations.CustomConnector;
import com.radiantlogic.iddm.annotations.Property;
import lombok.Getter;

/** List of the different built-in property sets available via the {@link Property} annotation. */
public enum InjectableProperties {

  /**
   * Provides access to the current connector configuration.
   *
   * <p>The returned {@link ReadOnlyProperties} contains the current values for custom properties
   * defined in the connector's {@link CustomConnector#metaJsonFile}.
   *
   * <p>This property is useful for retrieving configuration information needed to connect to the
   * backend, third-party data source.
   */
  CUSTOM_DATASOURCE_PROPERTIES("connection_details", ReadOnlyProperties.class),

  /** Provides access to information defined in the data source's schema as defined in IDDM. */
  SCHEMAS("schema", Schema.class),

  /**
   * Provides a mapping from the current request's base DN to the IDDM schema object type associated
   * within that DN.
   *
   * <p>For example, given an IDDM schema called "northwind" with a table called "App.Employees" and
   * a naming context "table=employees,o=northwind" configured to show "App.Employees" objects, the
   * {@link ReadOnlyProperties} entry returned by this method will contain the mapping: {@code
   * {"table=employees,o=northwind": "App.Employees"}}.
   *
   * <p>This property is most often used with {@link InjectableProperties#SCHEMAS} to retrieve the
   * specific {@link Schema} and {@link SchemaObject}s used by the naming context.
   */
  DN_TO_SCHEMA_MAPPING("collection_view_mapping", ReadOnlyProperties.class),

  /**
   * Provides access to the attributes and values used to form an entry's primary key.
   *
   * <p>For example, given a schema object created through IDDM's Context Builder where the primary
   * key is made up of "title", "givenName", and "sn" attributes, an LDAP entry might look like:
   * {@code user=President George Washington,ou=presidents,o=people}. The {@link ReadOnlyProperties}
   * provides by this property will contain the attribute names and used to generate the RDN:
   *
   * <p>{@code {"givenName": "George", "sn": "Washington", "title": "President"}}
   *
   * <p>This property can be useful when needing to parse a custom primary key.
   */
  PRIMARY_KEY_ATTRIBUTES("primary_key_attributes", ReadOnlyProperties.class),

  /**
   * Specifies the types of objects that should be searched based on base DN of incoming search
   * request.
   *
   * <p>If IDDM searches a subtree containing multiple object types (e.g., Users, Groups), then IDDM
   * will perform a unique search for each object type then aggregate the results. So this property
   * is almost ways (if not always) going to have a single value.
   *
   * <p>For example: <code>
   * {"names": ["APP.EMPLOYEES", "APP.SHIPPERS", "APP.ORDERS"]}
   * </code>
   */
  TARGET_SCHEMA_OBJECTS("target_schema_objects", ReadOnlyProperties.class),

  /**
   * Additional filters that should be applied before processing incoming requests.
   *
   * <p>Contains keys:
   *
   * <ul>
   *   <li>baseSearch
   *   <li>update
   *   <li>search
   * </ul>
   *
   * <p>These are the "Base Search", "Update", and "SQL Filter (WHERE clause)" filters that appear
   * in the Main Control Panel and in {@code ContentProperties} objects in the v8 API.
   */
  @Beta
  VIEW_FILTERS("view_filters", ReadOnlyProperties.class);

  @Getter private final Class<?> type;
  private final String label;

  InjectableProperties(String label, Class<?> type) {
    this.label = label;
    this.type = type;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/LdapRequest.java
================================================
package com.radiantlogic.iddm.base;

/** Interface marking LDAP specific requests. */
public interface LdapRequest extends Request {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/LdapResponse.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.ResponseEntity;
import javax.annotation.Nullable;
import lombok.NonNull;

/**
 * Represents an LDAP response containing arbitrary data.
 *
 * <p>This is an extension of {@link ResponseEntity<T>} that uses a {@link LdapResultCode} as its
 * status code type. This will most often be the base class for responses returned to IDDM.
 */
public class LdapResponse<T> extends ResponseEntity<T> {

  public LdapResponse(@NonNull LdapResultCode status) {
    super(status);
  }

  public LdapResponse(@NonNull LdapResultCode status, @Nullable T data) {
    super(status, data);
  }

  @Override
  public LdapResultCode getStatus() {
    return (LdapResultCode) status;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/LdapResultCode.java
================================================
package com.radiantlogic.iddm.base;

import java.util.Arrays;
import java.util.Optional;
import org.apache.commons.lang3.StringUtils;

/** Enumeration of LDAP result codes based on RFC 4511. */
public enum LdapResultCode implements StatusCode {

  /** Indicates the successful completion of an operation. */
  SUCCESS("success", 0),

  /**
   * Indicates that the operation is not properly sequenced with relation to other operations (of
   * same or different type). For example:
   *
   * <ul>
   *   <li>Client attempts to StartTLS [RFC4346] while there are other uncompleted operations or if
   *       a TLS layer was already installed.
   *   <li>Client sends a request that is only allowed for authenticated clients.
   *   <li>Client sends any request on a connection that is actively processing a bind.
   * </ul>
   *
   * <p>This result code should <em>not</em> be used for internal server errors; in that case, use
   * {@link LdapResultCode#OTHER} (80) instead.
   */
  OPERATIONS_ERROR("operationsError", 1),

  /** Indicates that the object does not exist in the DIT. */
  NO_SUCH_OBJECT("noSuchObject", 32),

  /** Indicates that the provided credentials (e.g., the user's name and password) are invalid. */
  INVALID_CREDENTIALS("invalidCredentials", 49),

  /** Indicates that the client does not have sufficient access rights to perform the operation. */
  INSUFFICIENT_ACCESS_RIGHTS("insufficientAccessRights", 50),

  /**
   * Indicates that the server or a subsystem needed to process the request is currently not
   * available to process the requested operation.
   */
  UNAVAILABLE("unavailable", 52),

  /**
   * Indicates the server has encountered an internal error. Use when a problem occurs for which
   * none of the other result codes is more appropriate.
   */
  OTHER("other", 80);

  private final String name;
  private final int value;

  LdapResultCode(String name, int value) {
    this.name = name;
    this.value = value;
  }

  public static Optional<LdapResultCode> fromString(final String value) {
    try {
      // Expects that the enum values are named using uppercase values (as is the Java standard)
      return Optional.of(valueOf(StringUtils.upperCase(value)));
    } catch (IllegalArgumentException ex) {
      return Optional.empty();
    }
  }

  public static Optional<LdapResultCode> fromInt(final int value) {
    // Essumes that there are no duplicate values in the enum
    return Arrays.stream(values()).filter(resultCode -> resultCode.asInt() == value).findFirst();
  }

  /** Use {@link LdapResultCode#asString} instead. */
  @Deprecated
  public String getName() {
    return this.name;
  }

  /** Use {@link LdapResultCode#asInt} instead. */
  @Deprecated
  public int getValue() {
    return this.value;
  }

  /** Returns a human-readable word describing the result as specified in RFC 4511 Section 4.1.9. */
  @Override
  public String asString() {
    return this.name;
  }

  /** Returns the integer value describing the result as specified in RFC 4511 Section 4.1.9. */
  @Override
  public int asInt() {
    return this.value;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/LdapSearchResponse.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.annotations.ManagedComponent;
import java.util.List;
import lombok.NonNull;

@ManagedComponent
public class LdapSearchResponse extends LdapResponse<List<SearchResultEntry>> {

  public LdapSearchResponse(
      @NonNull LdapResultCode resultCode, @NonNull List<SearchResultEntry> data) {
    super(resultCode, data);
  }

  public LdapSearchResponse addEntry(@NonNull SearchResultEntry entry) {
    assert this.data != null : "This class does not allow super.data to be null.";
    this.data.add(entry);
    return this;
  }

  public LdapSearchResponse addEntries(@NonNull List<SearchResultEntry> entries) {
    entries.forEach(this::addEntry);
    return this;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Logger.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.annotations.CustomConnector;
import com.radiantlogic.iddm.annotations.ManagedComponent;

/**
 * Logger interface.
 *
 * <p>Inject this interface as a constructor argument to a {@link ManagedComponent} or a {@link
 * CustomConnector} annotated class to get logging facility.
 *
 * <p>Injected logger implementation will provide log4j style message formatting.
 *
 * <p>Example:
 *
 * <pre>{@code
 * @ManagedComponent
 * public class MyClass {
 *   private final Logger logger;
 *
 *   public MyClass(Logger logger) {
 *     this.logger = logger;
 *   }
 *
 *   public void sendRequest(String url) {
 *     try {
 *       logger.info("Sending request to {}", url);
 *     } catch (Exception e) {
 *       logger.error(e, "Problem occurred while sending request to {}", url);
 *     }
 *   }
 * }
 * }</pre>
 */
public interface Logger {
  /**
   * Log a trace message.
   *
   * @param format log message format
   * @param arguments log message arguments
   */
  void trace(String format, Object... arguments);

  /**
   * Log a debug message.
   *
   * @param format log message format
   * @param arguments log message arguments
   */
  void debug(String format, Object... arguments);

  /**
   * Log an info message.
   *
   * @param format log message format
   * @param arguments log message arguments
   */
  void info(String format, Object... arguments);

  /**
   * Log a warning message.
   *
   * @param format log message format
   * @param arguments log message arguments
   */
  void warn(String format, Object... arguments);

  /**
   * Log an error message.
   *
   * @param format log message format
   * @param arguments log message arguments
   */
  void error(String format, Object... arguments);

  /**
   * Log an error message and exception.
   *
   * @param e the exception to log
   * @param format log message format
   * @param arguments log message arguments
   */
  void error(Exception e, String format, Object... arguments);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ModifyOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform write and update operations
 * against the back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided).
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements ModifyOperations<ModRequest, ModResult>
 *
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface ModifyOperations<IN extends Request, OUT extends Response> extends Connector {

  /**
   * Performs a modify (update) operation against the back-end.
   *
   * @param request describing the modification to perform in the back-end.
   * @return the connector's response to the modify request, including a status and possibly data.
   */
  OUT modify(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/NamingContextProperties.java
================================================
package com.radiantlogic.iddm.base;

import lombok.AllArgsConstructor;

@Deprecated
@AllArgsConstructor
public class NamingContextProperties {

  private String dn;

  public String getDN() {
    return this.dn;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/OperationType.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.ValidationUtils;
import java.util.Optional;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

/**
 * Enumeration of protocol agnostic operations.
 *
 * <p>These are not specifically LDAP operations, SQL operations, HTTP operations, etc. This
 * enumeration simply provides a standard vocabulary for naming operations that different protocols
 * and connectors might need to be aware of.
 */
public enum OperationType {
  AUTHENTICATE,
  CREATE,
  CONNECT,
  DELETE,
  MODIFY,
  READ,
  DISCONNECT;

  public static @NonNull Optional<OperationType> fromString(@NonNull final String name) {
    ValidationUtils.requireArgument(
        StringUtils.isNotBlank(name), "Operation type name must be non-empty.");

    switch (StringUtils.lowerCase(name)) {
      case "authenticate":
      case "bind":
        return Optional.of(AUTHENTICATE);
      case "create":
      case "add":
      case "insert":
        return Optional.of(CREATE);
      case "delete":
        return Optional.of(DELETE);
      case "modify":
      case "update":
        return Optional.of(MODIFY);
      case "read":
      case "search":
      case "select":
        return Optional.of(READ);
      case "disconnect":
      case "unbind":
        return Optional.of(DISCONNECT);
      case "connect":
      case "testConnectToBackend":
      case "testConnection":
        return Optional.of(CONNECT);
      default:
        return Optional.empty();
    }
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ReadOnlyProperties.java
================================================
package com.radiantlogic.iddm.base;

import com.google.common.collect.ImmutableMap;
import java.util.HashMap;
import java.util.Map;
import javax.annotation.Nullable;
import lombok.NonNull;

/**
 * Read-only data structure for storing properties injected using the {@link @Property} annotation.
 * Property names are case-insensitive for read operations.
 */
public final class ReadOnlyProperties {

  public static final class Builder {

    private final HashMap<String, Object> data = new HashMap<>();

    public Builder put(final String property, final Object value) {
      data.put(property, value);
      return this;
    }

    public ReadOnlyProperties build() {
      return new ReadOnlyProperties(data);
    }
  }

  public static Builder builder() {
    return new Builder();
  }

  /**
   * Store properties in an immutable map so they are guaranteed not to change. The original,
   * unmodified keys are not stored.
   */
  private final ImmutableMap<String, Object> internalMap;

  /** Returns a new instance loaded with values from the {@code Map} argument. */
  public ReadOnlyProperties(final Map<String, ?> other) {

    ImmutableMap.Builder<String, Object> mapBuilder =
        ImmutableMap.builderWithExpectedSize(other.size());

    // Convert the property names to support case-insensitivity
    for (Map.Entry<String, ?> entry : other.entrySet()) {
      if (entry.getKey() == null) {
        throw new IllegalArgumentException(
            String.format("%s does not support null property names.", this.getClass().getName()));
      }
      mapBuilder.put(convertKey(entry.getKey()), entry.getValue());
    }

    internalMap = mapBuilder.build();
  }

  /** Return the requested {@code property} if it exists; returns {@code null} if it does not. */
  public @Nullable Object get(@NonNull final String property) {
    return internalMap.get(convertKey(property));
  }

  /**
   * Returns {@code true} if the requested {@code property} exists; returns {@code null} otherwise.
   */
  public boolean containsProperty(@NonNull final String property) {
    return internalMap.containsKey(convertKey(property));
  }

  /** Returns {@code true} if this object contains no properties; returns {@code true} otherwise. */
  public boolean isEmpty() {
    return internalMap.isEmpty();
  }

  /** Convenience method that returns the read only properties as an immutable map. */
  public Map<String, Object> asMap() {
    return this.internalMap;
  }

  /**
   * Returns the given {@code key} in local-independent lowercase.
   *
   * <p>This implementation based on Apache Commons Collections CaseInsensitiveMap. From the class
   * documentation:
   *
   * <blockquote>
   *
   * <p>"Before keys are added to the map or compared to other existing keys, they are converted to
   * all lowercase in a locale-independent fashion by using information from the Unicode data file."
   *
   * </blockquote>
   */
  private @NonNull String convertKey(@NonNull final String key) {
    final char[] chars = key.toCharArray();
    for (int i = chars.length - 1; i >= 0; i--) {
      chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));
    }
    return new String(chars);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ReadOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can perform read operations against the
 * back-end data source.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided).
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements ReadOperations<SearchRequest, SearchResponse>
 * }</pre>
 *
 * The type parameters {@code IN} and {@code OUT} specify the request and response formats supported
 * by this class.
 */
public interface ReadOperations<IN extends Request, OUT extends Response> extends Connector {

  /**
   * Performs a search (read) operation against the back-end.
   *
   * @param request describing the search to perform.
   * @return the search result, including status and data.
   */
  OUT search(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Request.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This marker interface identifies objects as eligible for processing by {@link TypeConverter} and
 * {@link Connector} objects.
 *
 * <p>To use, the developer creates a new class that implements this interface. Doing this marks the
 * concrete implementation as a request that can be handled a concrete {@link Connector}
 * implementation. However, the developer is responsible for ensuring the connector knows how to
 * actually use the request.
 *
 * <p>It is strongly recommended (but not required) that classes implementing this interface be
 * designed as read-only data containers.
 */
public interface Request {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Response.java
================================================
package com.radiantlogic.iddm.base;

public interface Response {}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/ResponseStatus.java
================================================
package com.radiantlogic.iddm.base;

/** Replaced by {@link StatusCode} and {@link LdapResultCode}. */
@Deprecated
public enum ResponseStatus implements StatusCode {
  /** The operation was completed, and the client should receive a success response. */
  YES("yes"),
  /** TODO: Need to figure out what this value means */
  NO("no"),
  /**
   * The operation was completed, and the client should receive a success response. TODO: Why is
   * this separate from "yes"? Need to investigate whether the backend has any differences in
   * handling . If same, remove one of them.
   */
  OK("ok"),
  /**
   * The operation failed or could not be completed. The client should receive a failure response.
   */
  FAILED("failed"),
  /**
   * The operation was processed successfully, and processing of the operation should continue with
   * the next handler.
   */
  PROCEED("proceed"),
  /** The operation was completed, and results were returned. */
  PROCESS_RESULT("processresult");

  /** Returns a human-readable word describing the status. */
  public String asString() {
    return this.stringValue;
  }

  /** Returns the enum's ordinal value. */
  public int asInt() {
    return this.ordinal();
  }

  private final String stringValue;

  ResponseStatus(String stringValue) {
    this.stringValue = stringValue;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Schema.java
================================================
package com.radiantlogic.iddm.base;

import com.google.common.collect.ImmutableList;
import com.radiantlogic.iddm.ValidationUtils;
import java.util.List;
import java.util.Optional;
import lombok.Getter;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

/**
 * Represents the collection of schemas associated with a single data source.
 *
 * <p>Use this collection to iterate and search for schemas.
 *
 * <p>A class for describing the location and type of data stored in a data source.
 *
 * <p>TODO: Documentation below is temporary. Update while iterating.
 *
 * <p>This class tries to avoid impose or imply any meaning on the structure of the backend data.
 * Instead, it is meant as a record of in what "collections of data" different data can be found in
 * the backend. The semantic meaning of the data depends on the backend, and it's the developer's
 * responsibility to know that semantic meaning. For example, for a SQL backend, the "collections"
 * will be a tables. For a CSV backend, the "collections" may be CSV files that can be read.
 *
 * <p>The {@link SchemaObject} class takes a similar approach in that it describes the types of data
 * that appear in the collection while again trying to avoid imposing or implying any semantic
 * meaning for the data. The {@link SchemaObject}'s {@link Field}s describe the type of data in the
 * collection and where that data is found in the collection. For SQL, this is the fields of a
 * single table. For CSV files, this is information about the columns.
 *
 * @implNote Based on {@code com.rli.web.meta.schema.SchemaMeta} from IDDM, which is populated by
 *     calling SchemaMetaService.loadSchemaMeta(String schemaName, boolean isLdap);
 *     <p>TODO: Consider providing a tool that allows the customer to extract this Schema object
 *     from IDDM and save it for testing purposes. This is a rather complex object that is difficult
 *     to write from scratch for unit testing.
 * @apiNote AN IMPORTANT DESIGN POINT IS THAT WHILE IDDM VIEWS SQL AND CUSTOM DATA SOURCES AS
 *     RDBMS-STYLE STRUCTURES (E.G., WITH PRIMARY AND CANDIDATE KEYS), WE DON'T WANT THE USER TO SEE
 *     THINGS THAT WAY. THEY SHOULDN'T NEED TO WORRY ABOUT HOW IDDM STRUCTURES OR VIEWS THE DATA
 *     INTERNALLY.
 */
public class Schema {

  @Getter private final String dataSourceName;

  // TODO (M.Silva, 13Dec2024): Should this be a list or a table? Will user need easy table lookup?
  @NonNull private final ImmutableList<SchemaObject> schemaObjects;

  public Schema(String dataSourceName, @NonNull List<SchemaObject> schemaObjects) {
    this.dataSourceName = dataSourceName;
    this.schemaObjects = ImmutableList.copyOf(schemaObjects);
  }

  // TODO (M.Silva, 13Dec2024): Case-sensitivity is going to be a killer here. Decide how to handle
  // that.
  public Optional<SchemaObject> getSchemaObject(final String name) {
    ValidationUtils.requireNotBlank(name);

    // TODO (M.Silva, 13Dec2024): Quick and dirty implementation. Replace with an appropriate view.
    return this.schemaObjects.stream()
        .filter(collectionView -> StringUtils.equalsIgnoreCase(collectionView.getName(), name))
        .findFirst();
  }

  /**
   * Returns an immutable view of the collections list. Attempting to modify the list will throw a
   * {@link UnsupportedOperationException}.
   */
  public @NonNull List<SchemaObject> getSchemaObjects() {
    return this.schemaObjects;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/SchemaObject.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.ValidationUtils;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import org.apache.commons.lang3.StringUtils;

/**
 * A model object representing a backend data structure.
 *
 * @implNote Taken from {@code com.rli.web.meta.schema.TableView}.
 */
@AllArgsConstructor
@Getter
@Builder
public class SchemaObject {

  /** Name of the object. */
  private String name;

  private String objectClass;
  private String owner;
  private String baseTable;

  /**
   * Attribute name used to form the entry's RDN. For example, in "cn=Johnny Utah", the candidate
   * key name is "cn".
   */
  private String candidateKeyName;

  /**
   * Attributes to use when creating a unique, primary key for the entry. This list will often
   * contain only one entry. But additional attributes can be added to form the primary key, with
   * each being separated by colons (::).
   */
  @NonNull @Builder.Default
  private final List<String> primaryKeys =
      Collections.emptyList(); // Primary key RDN values. Visible in Context

  /**
   * Additional attributes that can be used to modify the displayed RDN. These attributes are not
   * used when generating the entry's primary key so these values are not required to be unique.
   */
  @NonNull @Builder.Default
  private final List<String> candidateKeys =
      Collections.emptyList(); // these are the non-mapped names

  @NonNull @Builder.Default private List<Field> fields = Collections.emptyList();

  /**
   * <em>Deprecated. Use builder instead.</em> Meant to help users when writing tests. Helps
   * mentally connect UI of Schema Manager to the SDK.
   *
   * @param rdnValue field whose value is used as the RDN value.
   */
  @Deprecated // TODO (M.Silva, 24April2025, API-2545) - Remove method. Use builder instead.
  public static SchemaObject create(
      @NonNull final String name,
      @NonNull final String objectClass,
      @NonNull final String rdnName,
      @NonNull final String rdnValue,
      @NonNull final List<Field> fields) {
    ValidationUtils.requireNotBlank(name, objectClass, rdnName, rdnValue);

    return SchemaObject.builder()
        .name(name)
        .objectClass(objectClass)
        .candidateKeyName(rdnName)
        .candidateKeys(Collections.singletonList(rdnValue))
        .fields(fields)
        .build();
  }

  // TODO: Case-sensitivity is going to be a killer here. Decide how to handle that.
  public Optional<Field> getField(final String name) {

    ValidationUtils.requireNotBlank(name);
    // TODO: Quick-and-dirty implementation. Replace with a proper view.
    return this.fields.stream()
        .filter(field -> StringUtils.equalsIgnoreCase(name, field.getName()))
        .findFirst();
  }

  // TODO: Case-sensitivity is going to be a killer here. Decide how to handle that.
  public boolean containsField(final String name) {
    ValidationUtils.requireNotBlank(name);
    return getField(name).isPresent();
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/SearchResultEntry.java
================================================
package com.radiantlogic.iddm.base;

import com.fasterxml.jackson.annotation.JsonGetter;
import com.radiantlogic.iddm.ValidationUtils;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import lombok.NonNull;
import lombok.ToString;
import org.apache.commons.lang3.ObjectUtils;

/**
 * Data structure for storing attributes of a single object returned from the backend. Ideally, the
 * internal structure is meant to match that of a backend object (e.g., same property names) but
 * this requirement is not strictly necessary.
 */
@ToString
public class SearchResultEntry {

  private boolean allowAddingKeys = true;

  /** Names should match the names of attributes from the backend. Keys are the attribute values. */
  private final Map<String, Object> attributes;

  public SearchResultEntry() {
    this.attributes = new HashMap<>();
  }

  public Object get(String key) {
    return attributes.getOrDefault(key, ObjectUtils.NULL);
  }

  /** The value can be multivalued if needed (e.g., array, list). */
  public SearchResultEntry put(@NonNull String key, Object value) {
    ValidationUtils.requireNotBlank(key);

    if (!allowAddingKeys && !attributes.containsKey(key)) {
      throw new IllegalStateException(
          "Search result entry is configured to reject new keys. Could not find existing key: "
              + key
              + ". Candidates: "
              + Arrays.toString(attributes.keySet().toArray()));
    }

    this.attributes.put(key, value);
    return this;
  }

  /**
   * Returns a Map view of the search results entry. The search result entry backing this view can
   * still be updated by calling its mutators (such as {@code put}) and those changes will be
   * reflected in the Map view returned by this method. But attempting to update the entry via this
   * map will cause an exception.
   */
  @JsonGetter("attributes")
  public Map<String, Object> asUnmodifiableMap() {
    return Collections.unmodifiableMap(this.attributes);
  }

  /**
   * Returns an entry with all keys populated from names in the schemaObject but with no values.
   * Returned {@code SearchResultEntry} will throw an exception when trying to add a value for a key
   * that does not already exist.
   */
  public static SearchResultEntry from(SchemaObject schemaObject) {
    SearchResultEntry searchResultEntry = new SearchResultEntry();
    for (Field field : schemaObject.getFields()) {
      searchResultEntry.put(field.getName(), null);
    }
    searchResultEntry.allowAddingKeys = false;
    return searchResultEntry;
  }

  // TODO: Maybe add a method for validating a SearchResultEntry against a given schema.
  //  to help the developer have confidence that the data they're returning to IDDM will be
  //  accepted and processed as expected.
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/SearchScope.java
================================================
package com.radiantlogic.iddm.base;

import static java.util.stream.Collectors.toMap;

import java.util.Map;
import java.util.Optional;
import java.util.stream.Stream;
import lombok.Getter;

@Getter
public enum SearchScope {
  BASE(0),
  ONE(1),
  SUB(2);

  private final int value;

  private static final Map<String, SearchScope> stringToEnum =
      Stream.of(values()).collect(toMap(Object::toString, e -> e));

  SearchScope(int value) {
    this.value = value;
  }

  /** Returns the SearchScope for the string value if it exists. */
  public static Optional<SearchScope> fromString(String symbol) {
    return Optional.ofNullable(stringToEnum.get(symbol.toUpperCase()));
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/StatusCode.java
================================================
package com.radiantlogic.iddm.base;

public interface StatusCode {

  /**
   * Returns a string representation of the status code.
   *
   * <p>Callers should make no assumptions about the format of the string returned by this method.
   * It can be a parseable number (ex: "1"), a word (ex: "SUCCESS"), or any other representation the
   * implementer deems appropriate.
   */
  String asString();

  /** Returns the status code represented as an integer. */
  int asInt();
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TestConnectionOperations.java
================================================
package com.radiantlogic.iddm.base;

/**
 * This interface defines methods for connectors that can test connections to external data sources,
 * such as a REST API endpoint or file.
 *
 * <p>To use, the developer needs only to create a class that implements this interface and each of
 * its methods (as no default implementations are provided).
 *
 * <p>
 *
 * <pre>{@code
 * class CustomConnector implements TestConnectionOperations<TestConnectionRequest, TestConnectionResponse>
 * }</pre>
 *
 * <p>The type parameters {@code IN} and {@code OUT} specify the request and response formats
 * supported by this class.
 */
public interface TestConnectionOperations<
        IN extends TestConnectionRequest, OUT extends TestConnectionResponse>
    extends Connector {

  public OUT testConnection(IN request);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TestConnectionRequest.java
================================================
package com.radiantlogic.iddm.base;

import java.text.MessageFormat;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.ToString;

/** This class represents a request to test the connection to a resource. */
@EqualsAndHashCode
@ToString
public final class TestConnectionRequest implements ConnectionRequest {

  /** The target URI for the connection request. */
  @NonNull private final Uri target;

  /** Create a request to test the connection to the URI identified resource. */
  public TestConnectionRequest(@NonNull final Uri uri) {
    this.target = uri;
  }

  /**
   * Create a request to test the connection to the URI identified resource.
   *
   * <p>Throws an {@code IllegalArgumentException} if the URI String argument is syntactically
   * invalid based on RFC 2396.
   */
  public static TestConnectionRequest from(@NonNull final String uri) {
    try {
      return new TestConnectionRequest(Uri.fromString(uri));
    } catch (IllegalArgumentException ex) {
      // Chain the exception to provide better context when the error occurs
      throw new IllegalArgumentException(
          MessageFormat.format(
              "Unable to create {0} because the given URI string (\"{1}\") is invalid.",
              TestConnectionRequest.class.getName(), uri),
          ex);
    }
  }

  /** Returns the target location for the connection request. */
  @Override
  public @NonNull Uri getTarget() {
    return this.target;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TestConnectionResponse.java
================================================
package com.radiantlogic.iddm.base;

import java.text.MessageFormat;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.ToString;

/** This class represents the result of a test connection operation. */
@EqualsAndHashCode
@ToString
public final class TestConnectionResponse implements ConnectionResponse {

  /** The target URI for the connection request. */
  @NonNull private final Uri target;

  private final boolean successful;

  /**
   * Create a new response indicating if the connection to the URI identified resource was
   * successful.
   */
  public TestConnectionResponse(final boolean successful, @NonNull final Uri uri) {
    this.successful = successful;
    this.target = uri;
  }

  /**
   * Create a new response indicating if the connection to the URI identified resource was
   * successful.
   *
   * <p>Throws an {@code IllegalArgumentException} if the URI String argument is syntactically
   * invalid based on RFC 2396.
   */
  public static TestConnectionResponse create(final boolean successful, @NonNull final String uri) {
    try {
      return new TestConnectionResponse(successful, Uri.fromString(uri));
    } catch (IllegalArgumentException ex) {
      // Chain the exception to provide better context when the error occurs
      throw new IllegalArgumentException(
          MessageFormat.format(
              "Unable to create {0} because the given URI string (\"{1}\") is invalid.",
              TestConnectionResponse.class.getName(), uri),
          ex);
    }
  }

  /** Returns the target location of the connection response. */
  @Override
  public @NonNull Uri getTarget() {
    return this.target;
  }

  /** Returns true if the connection was successful and false otherwise. */
  public boolean isSuccessful() {
    return successful;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TypeConverter.java
================================================
package com.radiantlogic.iddm.base;

/**
 * Interface for converting between data types.
 *
 * <p>To use, the developer needs to implement the {@link TypeConverter#convert(FROM source)} method
 * for converting from one data type to the other
 */
public interface TypeConverter<FROM, TO> {

  TO convert(FROM source);
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TypePair.java
================================================
package com.radiantlogic.iddm.base;

import com.google.common.reflect.TypeToken;
import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.NonNull;
import lombok.ToString;

/**
 * Tuple structure for storing {@link TypeToken} data.
 *
 * <p>This class was created to easily store information about {@link TypeConverter} generic
 * arguments {@code FROM} and {@code TO}. For example, the {@code TypePair} objects can be used as
 * keys for a {@code Map} or cache of type converters.
 */
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@EqualsAndHashCode
@ToString
public final class TypePair {

  @NonNull private final TypeToken<?> from;

  @NonNull private final TypeToken<?> to;

  public static TypePair create(@NonNull final Class<?> from, @NonNull final Class<?> to) {
    return new TypePair(TypeTokenFactory.of(from), TypeTokenFactory.of(to));
  }

  public static TypePair create(@NonNull final TypeToken<?> from, @NonNull final TypeToken<?> to) {
    return new TypePair(from, to);
  }

  public @NonNull TypeToken<?> from() {
    return this.from;
  }

  public @NonNull TypeToken<?> to() {
    return this.to;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/TypeTokenFactory.java
================================================
package com.radiantlogic.iddm.base;

import com.google.common.reflect.TypeParameter;
import com.google.common.reflect.TypeToken;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;

/**
 * Utility class for creating Google Guava {@link TypeToken} objects.
 *
 * <p>This class is particular useful when creating type tokens that need to dynamically resolve
 * generic type arguments objects where the actual type is not known until runtime.
 *
 * <p>For example, we can easily create a new {@code TypeToken} for a {@code Map} object if we know
 * the key and value class types at <em>compile</em> time:
 *
 * <pre>{@code
 * new TypeToken<Map<String, Integer>>() {}
 * }</pre>
 *
 * But if the key and value class types ({@code String} and {@code Integer} respectively) are not
 * known until runtime, then extra work is involved, and it can make the caller code messy.
 *
 * <p>This class attempts to solve those issues by providing easy to use methods for common
 * collection types. For example, the two type tokens created below are equal:
 *
 * <pre>{@code
 * // Generic types are known at compile time
 * TypeToken<Map<SearchRequest, LdapSearchResponse>> typeToken =
 *     new TypeToken<Map<SearchRequest, LdapSearchResponse>>() {};
 * }</pre>
 *
 * <pre>{@code
 * // Dynamically detecting generic type from an object at runtime
 * TypeToken<?> typeToken = TypeTokenFactory.ofMap(
 *     searchRequest.getClass(), searchResponse.getClass()
 * );
 * }</pre>
 *
 * <p><b>Important:</b> This class has not been tested with nested types, such as {@code
 * List<List<Object>>}, so be careful.
 */
public final class TypeTokenFactory {

  public static <T> TypeToken<T> of(Class<T> type) {
    return TypeToken.of(type);
  }

  public static TypeToken<?> of(Type type) {
    return TypeToken.of(type);
  }

  public static <T> TypeToken<List<T>> listOf(Class<T> cls) {
    return new TypeToken<List<T>>() {}.where(new TypeParameter<T>() {}, TypeToken.of(cls));
  }

  /**
   * Returns a {@code TypeToken} with the generic arguments {@code key} and {@code value} resolved
   * at runtime.
   *
   * <p>
   */
  public static <K, V> TypeToken<Map<K, V>> mapOf(Class<K> key, Class<V> value) {
    return new TypeToken<Map<K, V>>() {}.where(new TypeParameter<K>() {}, TypeToken.of(key))
        .where(new TypeParameter<V>() {}, TypeToken.of(value));
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/base/Uri.java
================================================
package com.radiantlogic.iddm.base;

import java.net.URI;
import java.net.URISyntaxException;
import lombok.AccessLevel;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NonNull;

/**
 * This class is an immutable URI reference that conforms to <a
 * href="http://www.faqs.org/rfcs/rfc2396.html">RFC 2396</a>.
 */
@EqualsAndHashCode
public abstract class Uri implements Comparable<Uri> {

  /*
   * INTERNAL DOCUMENTATION -- Design Rationale
   *
   * This abstract class defines a public interface for the SDK.
   *
   * Private concrete implementations (such as StringUri) can be added as needed. But any
   * new implementations should be opaque to SDK users.
   *
   * This approach allows providing multiple concrete implementations and updating those
   * implementations without breaking SDK user code (because users can reference only the
   * Uri class, not its subclasses). This is effectively the GoF Strategy Pattern.
   *
   * The public abstract class exposes common methods for working with URIs. In many (if not most
   * or all) cases, work is delegated to a private java.net.URI instance, effectively making this
   * Uri class a proxy. But if functionality needs to change, such as a method behaving differently
   * based on the URI scheme (e.g., "file", "http"), then the corresponding method in the Uri
   * class should be made abstract, and concrete implementations provided by private Uri
   * subclasses (e.g., FileUri extends Uri, HttpUri extends Uri).
   */

  /** Internal URI object to which work is delegated. */
  @Getter(AccessLevel.PACKAGE)
  private final URI uri;

  /** An empty URI, equivalent to "". */
  public static final Uri EMPTY = new StringUri("");

  /**
   * Create a new instance from the path.
   *
   * <p>Throws an {@link IllegalArgumentException} if the path is not syntactically valid URI.
   */
  public static Uri fromString(@NonNull final String path) {
    return new StringUri(path);
  }

  /** Private constructor to prevent external subclassing since the class is not final. */
  private Uri(@NonNull final String path) {
    try {
      uri = new URI(path);
    } catch (URISyntaxException ex) {
      throw new IllegalArgumentException("Invalid URI syntax.");
    }
  }

  /**
   * Returns true if this URI is opaque, such as "file:/opt/foo/bar.json". A URI is opaque if it is
   * both an absolute path and does not start with a '/'.
   */
  public boolean isOpaque() {
    return uri.isOpaque();
  }

  /** Returns true if this URI is absolute, meaning it contains an explicit scheme component. */
  public boolean isAbsolute() {
    return uri.isAbsolute();
  }

  /** Returns the scheme of this URI. Example: "http" or "file". */
  public String getScheme() {
    return uri.getScheme();
  }

  /** Returns the decoded scheme-specific part of this URI. */
  public String getSchemeSpecificPart() {
    return uri.getSchemeSpecificPart();
  }

  /**
   * Returns the decoded user information from the authority. For example, for the authority
   * "user@host:port", this method will return "user".
   */
  public String getUserInfo() {
    return uri.getUserInfo();
  }

  /** Returns the decoded authority portion of this URI. Example: "user@radiantlogic.com:443". */
  public String getAuthority() {
    return uri.getAuthority();
  }

  /** Returns the host component of this URI. */
  public String getHost() {
    return uri.getHost();
  }

  /** Returns the port portion of this URI. */
  public int getPort() {
    return uri.getPort();
  }

  /** Returns the decoded path. */
  public String getPath() {
    return uri.getPath();
  }

  /**
   * Returns the decoded query portion of this URI. The query portion begins after the first
   * question mark ('?') and is terminated by the number sign ('#') or the end of the URI.
   */
  public String getQuery() {
    return uri.getQuery();
  }

  /**
   * Returns the decoded fragment portion of this URI, which is everything after the number sign
   * ('#').
   */
  public String getFragment() {
    return uri.getFragment();
  }

  /** Returns this content of this Uri as a string. */
  @Override
  public String toString() {
    return uri.toString();
  }

  /**
   * Compares the string representation of this Uri to that of the other Uri (as defined by {@link
   * String#compareTo}).
   */
  @Override
  public int compareTo(final Uri other) {
    return uri.compareTo(other.getUri());
  }

  /** Generic, concrete string representation of a URI. */
  private static final class StringUri extends Uri {

    private StringUri(@NonNull final String path) {
      super(path);
    }
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginConfigurationException.java
================================================
package com.radiantlogic.iddm.exceptions;

/**
 * This exception indicates that there is a problem with a plugin's metadata or configuration
 * preventing the operation which threw it.
 */
public class PluginConfigurationException extends PluginException {
  /**
   * Create a PluginConfigurationException with a detail message.
   *
   * @param message
   */
  public PluginConfigurationException(String message) {
    super(message);
  }

  /**
   * Create a PluginConfigurationException with a detail message and the error which caused it.
   *
   * @param message
   * @param cause
   */
  public PluginConfigurationException(String message, Throwable cause) {
    super(message, cause);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginException.java
================================================
package com.radiantlogic.iddm.exceptions;

/**
 * This exception indicates that a problem has occurred with usage of an IDDM plugin.
 *
 * <p>See {@link PluginConfigurationException} and {@link PluginLoadingException}.
 */
public abstract class PluginException extends Exception {

  // IMPLEMENTATION NOTE:  Only supporting constructors w/detail message, to push callers to always
  // include one.
  protected PluginException(String message) {
    super(message);
  }

  protected PluginException(String message, Throwable cause) {
    super(message, cause);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginLoadingException.java
================================================
package com.radiantlogic.iddm.exceptions;

/**
 * This Exception indicates that something fatal went wrong with loading or handling of a plugin,
 * not related to the validity of its metadata. Plugin handling functions will throw this if there
 * are general IO errors or similar.
 */
public class PluginLoadingException extends PluginException {
  /**
   * Create a PluginLoadingException with a detail message.
   *
   * @param message
   */
  public PluginLoadingException(String message) {
    super(message);
  }

  /**
   * Create a PluginLoadingException with a detail message and the error which caused it.
   *
   * @param message
   * @param cause
   */
  public PluginLoadingException(String message, Throwable cause) {
    super(message, cause);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginLoadingRuntimeException.java
================================================
package com.radiantlogic.iddm.exceptions;

public class PluginLoadingRuntimeException extends PluginRuntimeException {

  public PluginLoadingRuntimeException(String message) {
    super(message);
  }

  public PluginLoadingRuntimeException(String s, Throwable throwable) {
    super(s, throwable);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginOperationNotSupportedException.java
================================================
package com.radiantlogic.iddm.exceptions;

import com.radiantlogic.iddm.base.Connector;
import com.radiantlogic.iddm.base.OperationType;
import java.text.MessageFormat;
import lombok.NonNull;

/**
 * Unchecked exception thrown to indicate the plugin/connector does not support the request type it
 * received.
 */
public class PluginOperationNotSupportedException extends PluginRuntimeException {

  private final OperationType operationType;

  private final Class<? extends Connector> connectorClass;

  /**
   * Create a new exception with arguments specifying the requested operation type that is not
   * supported ({@code requestedOperationType}) by the connector class ({@code connectorClass}).
   */
  public PluginOperationNotSupportedException(
      @NonNull final OperationType requestedOperationType,
      @NonNull final Class<? extends Connector> connectorClass) {
    super();
    this.operationType = requestedOperationType;
    this.connectorClass = connectorClass;
  }

  @Override
  public String getMessage() {
    return MessageFormat.format(
        "Connector class {0} does not support the request operation type {1}.",
        connectorClass.getName(), operationType.toString());
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/exceptions/PluginRuntimeException.java
================================================
package com.radiantlogic.iddm.exceptions;

/**
 * Unchecked base exception for plugin / connector errors.
 *
 * <p>This exception should be used when there is no reasonable expectation the caller can or should
 * recover from the error.
 */
public abstract class PluginRuntimeException extends RuntimeException {

  protected PluginRuntimeException() {
    super();
  }

  public PluginRuntimeException(String message) {
    super(message);
  }

  public PluginRuntimeException(String s, Throwable throwable) {
    super(s, throwable);
  }

  public PluginRuntimeException(Throwable throwable) {
    super(throwable);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ldap/AddRequest.java
================================================
package com.radiantlogic.iddm.ldap;

import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.base.LdapRequest;
import javax.naming.directory.Attributes;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/** Implements an LDAP "Add Request" based on RFC 4511. */
@Getter
@Builder(toBuilder = true)
@ToString
public final class AddRequest implements LdapRequest {

  /** Specifies the DN of the entry to be added. */
  @NonNull private final DN dn;

  /** Specifies the attributes that make up the content of the entry being added. */
  @NonNull private final Attributes attributes;

  /** Creates a new {@code AddRequest} using the given arguments. */
  public static AddRequest create(@NonNull final DN dn, @NonNull final Attributes attributes) {
    return new AddRequest(dn, attributes);
  }

  private AddRequest(@NonNull final DN dn, @NonNull final Attributes attributes) {
    this.dn = dn;
    this.attributes = attributes;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ldap/BindRequest.java
================================================
package com.radiantlogic.iddm.ldap;

import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.base.AuthenticationRequest;
import com.radiantlogic.iddm.base.LdapRequest;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/** Implements an LDAP "Bind Request" based on RFC 4511. */
@Getter
@Builder(toBuilder = true)
@ToString
public final class BindRequest implements LdapRequest, AuthenticationRequest {

  @NonNull private final DN dn;

  @NonNull private final String passwordEntry;

  public static BindRequest create(@NonNull final DN dn, @NonNull final String passwordEntry) {
    return new BindRequest(dn, passwordEntry);
  }

  private BindRequest(@NonNull final DN dn, @NonNull final String passwordEntry) {
    this.dn = dn;
    this.passwordEntry = passwordEntry;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ldap/DeleteRequest.java
================================================
package com.radiantlogic.iddm.ldap;

import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.base.LdapRequest;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/** Implements an LDAP "Delete Request" based on RFC 4511. */
@Getter
@Builder(toBuilder = true)
@ToString
public final class DeleteRequest implements LdapRequest {

  /** Specifies the DN of the entry to be deleted. */
  @NonNull private final DN dn;

  /** Creates a new {@code DeleteRequest} for the given distinguished name. */
  public static DeleteRequest create(@NonNull final DN dn) {
    return new DeleteRequest(dn);
  }

  private DeleteRequest(@NonNull final DN dn) {
    this.dn = dn;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ldap/ModifyRequest.java
================================================
package com.radiantlogic.iddm.ldap;

import com.google.common.collect.ImmutableList;
import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.Modification;
import com.radiantlogic.iddm.base.LdapRequest;
import java.util.List;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/** Implements an LDAP "Modify Request" based on RFC 4511. */
@Getter
@Builder(toBuilder = true)
@ToString
public final class ModifyRequest implements LdapRequest {

  /** Specifies the DN of the entry to be modified. */
  @NonNull private final DN dn;

  /** Specifies the modifications to be applied to the entry. */
  @NonNull private final List<Modification> modifications;

  /** Creates a new {@code ModifyRequest} using the given arguments. */
  public static ModifyRequest create(
      @NonNull final DN dn, @NonNull final List<Modification> modifications) {
    return new ModifyRequest(dn, modifications);
  }

  private ModifyRequest(@NonNull final DN dn, @NonNull final List<Modification> modifications) {
    this.dn = dn;
    this.modifications = ImmutableList.copyOf(modifications);
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/ldap/SearchRequest.java
================================================
package com.radiantlogic.iddm.ldap;

import static com.radiantlogic.iddm.ValidationUtils.requireArgument;

import com.radiantlogic.iddm.DN;
import com.radiantlogic.iddm.SearchFilter;
import com.radiantlogic.iddm.base.LdapRequest;
import com.radiantlogic.iddm.base.SearchScope;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import lombok.Builder;
import lombok.Getter;
import lombok.NonNull;
import lombok.ToString;

/** Implements an LDAP "Search Request" based on RFC 4511. */
@Getter
@Builder(toBuilder = true)
@ToString
public final class SearchRequest implements LdapRequest {

  @Getter
  public enum DereferencePolicy {
    NEVER(0),
    SEARCHING(1),
    FINDING(2),
    ALWAYS(3);

    private final int value;

    DereferencePolicy(final int value) {
      this.value = value;
    }
  }

  /** Specified the starting DN for the search. */
  @NonNull private final DN baseDN;

  /** Specifies the scope of entries that will be searched. */
  @NonNull private final SearchScope searchScope;

  /** Specifies the search criteria. */
  @NonNull @Builder.Default
  private final SearchFilter filter = SearchFilter.from("(objectclass=*)");

  /** Specifies the requested attributes. */
  // TODO (M.Silva, 21Jan2025, API-2542): Need to add constants for special values
  @NonNull private List<String> attributes = Collections.emptyList();

  /** Specifies how the LDAP server should treat any aliases encountered during the search. */
  @NonNull @Builder.Default
  private final DereferencePolicy dereferencePolicy = DereferencePolicy.NEVER;

  /**
   * Specifies the maximum number of entries that should be returned from the search. A value of
   * zero indicates no limit.
   */
  @Builder.Default private final int sizeLimit = 0;

  /**
   * Specifies the maximum length of time, in seconds, that the server should spend processing the
   * search.
   */
  @Builder.Default private final int timeLimit = 0;

  @Builder.Default private final boolean typesOnly = false;

  public static SearchRequest create(
      @NonNull final DN baseDN,
      @NonNull final SearchScope scope,
      @NonNull final SearchFilter filter,
      @NonNull final String... attributes) {

    return SearchRequest.builder()
        .baseDN(baseDN)
        .searchScope(scope)
        .filter(filter)
        .attributes((attributes.length > 0) ? Arrays.asList(attributes) : Collections.emptyList())
        .build();
  }

  private SearchRequest(
      @NonNull final DN baseDN,
      @NonNull final SearchScope searchScope,
      @NonNull final SearchFilter filter,
      @NonNull final List<String> attributes,
      @NonNull final DereferencePolicy dereferencePolicy,
      final int sizeLimit,
      final int timeLimit,
      final boolean typesOnly) {

    // TODO (M.Silva, 13Feb2025, API-2542) - Replace with Hibernate Validator.
    //  But note Hibernate Validator prevented RadiantOneSuite from building for some users, giving
    //  the error:
    //    Caused by: java.lang.NoClassDefFoundError: javax/validation/Validator
    requireArgument(sizeLimit >= 0, "Size limit must be greater than or equal to 0.");
    requireArgument(timeLimit >= 0, "Time limit must be greater than or equal to 0.");

    this.baseDN = baseDN;
    this.searchScope = searchScope;
    this.filter = filter;
    this.attributes = attributes;
    this.dereferencePolicy = dereferencePolicy;
    this.sizeLimit = sizeLimit;
    this.timeLimit = timeLimit;
    this.typesOnly = typesOnly;
  }
}



================================================
FILE: src/main/java/com/radiantlogic/iddm/test/TestLogger.java
================================================
package com.radiantlogic.iddm.test;

import static java.text.MessageFormat.format;

import com.radiantlogic.iddm.base.Logger;

/**
 * Implementation of logger that should be used when testing locally. This class should never be
 * used in production.
 *
 * <p>Prints log messages to the console.
 */
public final class TestLogger implements Logger {
  @Override
  public void trace(final String format, final Object... arguments) {
    println(format("[TRACE] {0}", formatLog4jStyle(format, arguments)));
  }

  @Override
  public void debug(final String format, final Object... arguments) {
    println(format("[DEBUG] {0}", formatLog4jStyle(format, arguments)));
  }

  @Override
  public void info(final String format, final Object... arguments) {
    println(format("[INFO] {0}", formatLog4jStyle(format, arguments)));
  }

  @Override
  public void warn(final String format, final Object... arguments) {
    println(format("[WARN] {0}", formatLog4jStyle(format, arguments)));
  }

  @Override
  public void error(final String format, final Object... arguments) {
    println(format("[ERROR] {0}", formatLog4jStyle(format, arguments)));
  }

  @Override
  public void error(final Exception e, final String format, final Object... arguments) {
    println(format("[ERROR] {0}", formatLog4jStyle(format, arguments)));
    e.printStackTrace();
  }

  private static void println(String s) {
    System.out.println(s);
  }

  private static String formatLog4jStyle(String pattern, Object... arguments) {
    if (pattern == null || arguments == null) {
      return pattern;
    }

    // Convert log4j style {} placeholders to MessageFormat style {0}, {1}, etc.
    final StringBuilder converted = new StringBuilder(pattern.length() + 4 * arguments.length);
    int position = 0;
    int i = 0;
    int placeholderPos;

    while ((placeholderPos = pattern.indexOf("{}", position)) != -1) {
      converted.append(pattern, position, placeholderPos);
      converted.append("{").append(i++).append("}");
      position = placeholderPos + 2;
    }

    // Append the rest of the pattern after the last placeholder
    if (position < pattern.length()) {
      converted.append(pattern.substring(position));
    }

    // Use MessageFormat to format the string
    return format(converted.toString(), arguments);
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/DNTest.java
================================================
package com.radiantlogic.iddm;

import static org.junit.jupiter.api.Assertions.assertEquals;

import lombok.SneakyThrows;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class DNTest {

  /**
   * Documenting the behavior of {@link com.unboundid.ldap.sdk.DN}, which provide the core
   * functionality for {@link DN}.
   */
  @Nested
  class UnboundID {

    @Test
    @SneakyThrows
    void emptyStrings() {
      assertEquals(new com.unboundid.ldap.sdk.DN(""), new com.unboundid.ldap.sdk.DN(""));
    }

    @Test
    @SneakyThrows
    void blankStrings() {
      assertEquals(new com.unboundid.ldap.sdk.DN("  "), new com.unboundid.ldap.sdk.DN("  "));
    }

    @Test
    @SneakyThrows
    void nullStrings() {
      assertEquals(
          new com.unboundid.ldap.sdk.DN("", null, false),
          new com.unboundid.ldap.sdk.DN("   ", null, false));
    }
  }

  @Test
  @SneakyThrows
  void emptyStrings() {
    assertEquals(DN.from(""), DN.from(""));
  }

  @Test
  @SneakyThrows
  void blankStrings() {
    assertEquals(DN.from("  "), DN.from("  "));
  }

  @Test
  @SneakyThrows
  void nullStrings() {
    assertEquals(DN.from(""), DN.from("   "));
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/SearchFilterTest.java
================================================
package com.radiantlogic.iddm;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrowsExactly;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.util.List;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class SearchFilterTest {

  @Test
  void from() {}

  @Test
  void getComponentsEQUALS() {
    List<SearchFilter> components = SearchFilter.from("(objectclass=*)").getComponents();
    assertTrue(components.isEmpty());
  }

  @Test
  void getComponentsAND() {
    List<SearchFilter> components =
        SearchFilter.from("(&(firstName=Johnny)(givenName=Utah))").getComponents();
    assertEquals(2, components.size());

    SearchFilter firstNameFilter = components.get(0);
    assertNotNull(firstNameFilter);
    assertTrue(StringUtils.equalsAnyIgnoreCase("firstName", firstNameFilter.getAttribute()));
    assertEquals("Johnny", firstNameFilter.getValue());
    assertEquals(SearchFilter.Type.EQUAL, firstNameFilter.getType());
  }

  @Test
  void getComponents3() {
    List<SearchFilter> components =
        SearchFilter.from(
                "(&"
                    + "(&(firstName=Johnny)(givenName=Utah))"
                    + "(&(employer=FBI)(city=Langley))"
                    + ")")
            .getComponents();
    assertEquals(2, components.size());
  }

  @Test
  void getValue1() {
    assertEquals("*", SearchFilter.from("(objectclass=*)").getValue());
  }

  @Test
  void getValue2() {
    assertEquals("User", SearchFilter.from("(objectclass=User)").getValue());
  }

  @Test
  void getAttribute() {
    assertEquals("objectclass", SearchFilter.from("(objectclass=*)").getAttribute());
  }

  @Test
  void testEquals0() {
    // case-insensitive attribute names
    assertEquals(SearchFilter.from("objectClass=*"), SearchFilter.from("objectclass=*"));
  }

  @Test
  void testEquals1() {
    // the whitespace means these are different attributes.
    assertNotEquals(SearchFilter.from("objectClass=*"), SearchFilter.from("objectclass =*"));
  }

  @Test
  void testEquals2() {
    // the whitespace means these are different attributes.
    assertNotEquals(SearchFilter.from("objectClass      =*"), SearchFilter.from("objectclass =*"));
  }

  @Test
  void testEquals3() {
    // adding whitespace before the start makes it a Substring filter instead of a Presence filter
    assertNotEquals(SearchFilter.from("objectclass=*"), SearchFilter.from("objectclass= *"));
  }

  @DisplayName("(objectclass= *) is an unsupported substring filter")
  @Test
  void testGetType1() {
    assertThrowsExactly(
        NullPointerException.class, () -> SearchFilter.from("(objectclass= *)").getType());
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/ValidationUtilsTest.java
================================================
package com.radiantlogic.iddm;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrowsExactly;

import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

class ValidationUtilsTest {

  private static class Foo {
    /* ...empty class for testing types... */
  }

  private static class Bar extends Foo {
    /* ...empty class for testing types... */
  }

  @Test
  void requireType1() {
    assertDoesNotThrow(() -> ValidationUtils.requireType(new Bar(), Foo.class, null));
  }

  @Test
  void requireType2() {
    assertThrowsExactly(
        ClassCastException.class,
        () ->
            ValidationUtils.requireType(
                new Foo(),
                Bar.class,
                "Cannot assign an object of the superclass to a variable of its subclass."));
  }

  /** Tests documenting the behavior of the ValidationUtils.formatMessage method. */
  @Nested
  class FormatMessage {

    @Test
    void formatMessage1() {
      assertEquals("Hello world", ValidationUtils.formatMessage("Hello world"));
    }

    @Test
    void formatMessage2() {
      assertEquals("Hello world", ValidationUtils.formatMessage("Hello world", null));
    }

    @Test
    void formatMessage3() {
      assertEquals("Hello world", ValidationUtils.formatMessage("Hello world", new String[0]));
    }

    @Test
    void formatMessage4() {
      assertEquals(
          "Hello world [one]", ValidationUtils.formatMessage("Hello world", new String[] {"one"}));
    }

    @Test
    void formatMessage5() {
      assertEquals(
          "Hello world [one, two]", ValidationUtils.formatMessage("Hello world", "one", "two"));
    }

    @Test
    void formatMessage6() {
      assertEquals(
          "Hello world one [two]", ValidationUtils.formatMessage("Hello world %s", "one", "two"));
    }

    @Test
    void formatMessage7() {
      assertEquals(
          "Hello world one two", ValidationUtils.formatMessage("Hello world %s %s", "one", "two"));
    }
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/base/DemoConnector.java
================================================
package com.radiantlogic.iddm.base;

import com.radiantlogic.iddm.ResponseEntity;
import com.radiantlogic.iddm.annotations.CustomConnector;
import com.radiantlogic.iddm.ldap.SearchRequest;
import java.io.Serializable;

@CustomConnector(metaJsonFile = "null")
class DemoConnector
    implements ReadOperations<LdapRequest, ResponseEntity<String>>,
        ModifyOperations<SearchRequest, ResponseEntity<?>>,
        Serializable {

  @Override
  public ResponseEntity<String> search(LdapRequest request) {
    return null;
  }

  @Override
  public ResponseEntity<Number> modify(SearchRequest request) {
    return null;
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/base/FieldTest.java
================================================
package com.radiantlogic.iddm.base;

import static com.radiantlogic.iddm.base.Field.Type;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;

import org.junit.jupiter.api.Test;

class FieldTest {

  @Test
  void fromString1() {
    assertEquals(Type.INTEGER, Field.Type.fromString("INTEGER").get());
  }

  @Test
  void fromString2() {
    assertEquals(Type.BOOLEAN, Field.Type.fromString("boolean").get());
  }

  @Test
  void fromString3() {
    assertEquals(Type.STRING, Field.Type.fromString("VARCHAR(80)").get());
  }

  @Test
  void fromString4() {
    assertFalse(Field.Type.fromString("invalid_value").isPresent());
  }

  @Test
  void fromString5() {
    assertEquals(Type.BLOB, Field.Type.fromString("BLOB(1048576)").get());
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/base/SearchScopeTest.java
================================================
package com.radiantlogic.iddm.base;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class SearchScopeTest {

  @DisplayName("BASE scope fromString is case-insensitive")
  @ParameterizedTest
  @ValueSource(strings = {"base", "BASE", "bASe"})
  void baseCaseInsensitive(final String value) {
    assertThat(SearchScope.fromString(value)).isPresent().get().isEqualTo(SearchScope.BASE);
  }

  @DisplayName("ONE scope fromString is case-insensitive")
  @ParameterizedTest
  @ValueSource(strings = {"one", "ONE", "OnE"})
  void oneCaseInsensitive(final String value) {
    assertThat(SearchScope.fromString(value)).isPresent().get().isEqualTo(SearchScope.ONE);
  }

  @DisplayName("SUB scope fromString is case-insensitive")
  @ParameterizedTest
  @ValueSource(strings = {"sub", "SUB", "suB"})
  void sub(final String value) {
    assertThat(SearchScope.fromString(value)).isPresent().get().isEqualTo(SearchScope.SUB);
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/base/TypeConverterTest.java
================================================
package com.radiantlogic.iddm.base;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assumptions.assumeTrue;

import com.google.common.reflect.TypeToken;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

// TODO (M.Silva, 28Feb2025, API-2628) - Complex class that has higher likelihood of bugs. Make
//  sure it's very well tests and its behavior clearly documented.
class TypeConverterTest {

  private TypePair typePairFrom(TypeConverter<?, ?> typeConverter) {
    assumeTrue(TypeConverter.class.getTypeParameters().length == 2);
    TypeToken<?> inType =
        TypeToken.of(typeConverter.getClass())
            .resolveType(TypeConverter.class.getTypeParameters()[0]);
    TypeToken<?> outType =
        TypeToken.of(typeConverter.getClass())
            .resolveType(TypeConverter.class.getTypeParameters()[1]);
    return TypePair.create(inType, outType);
  }

  @DisplayName("TypeConverter<String,String>().supports( TypePair(String,String) )")
  @Test
  void support1() {

    TypeConverter<String, String> typeConverter =
        new TypeConverter<String, String>() {
          @Override
          public String convert(String source) {
            return "";
          }
        };

    TypePair expected =
        TypePair.create(TypeTokenFactory.of(String.class), TypeTokenFactory.of(String.class));

    assertThat(typePairFrom(typeConverter)).isEqualTo(expected);
  }

  @DisplayName("TypeConverter<List<Integer>,String>().supports( TypePair(List<Integer>,String) )")
  @Test
  void support2() {

    TypeConverter<List<Integer>, String> typeConverter =
        new TypeConverter<List<Integer>, String>() {
          @Override
          public String convert(List<Integer> source) {
            return "";
          }
        };

    TypePair expected =
        TypePair.create(TypeTokenFactory.listOf(Integer.class), TypeTokenFactory.of(String.class));

    assertThat(typePairFrom(typeConverter)).isEqualTo(expected);
  }

  @DisplayName("TypeConverter<?,String>().supports( TypePair(List<Integer>,String) )")
  @Test
  void support3() {

    TypeConverter<?, String> typeConverter =
        new TypeConverter<List<Integer>, String>() {
          @Override
          public String convert(List<Integer> source) {
            return "";
          }
        };

    TypePair expected =
        TypePair.create(TypeTokenFactory.listOf(Integer.class), TypeTokenFactory.of(String.class));

    assertThat(typePairFrom(typeConverter)).isEqualTo(expected);
  }

  @DisplayName("Special case of supports. See code.")
  @Test
  void supports4() {

    // Given a type converter with a wildcard type
    //  ...making this statement illegal: typeConverter.convert(Collections.emptyList())
    //  Because...
    //    Required: capture of ?
    //    Provided: List <java.lang.Object>
    TypeConverter<?, ?> typeConverter =
        new TypeConverter<List<Integer>, String>() {
          @Override
          public String convert(List<Integer> source) {
            return "";
          }
        };

    TypePair typePair =
        TypePair.create(new TypeToken<List<Integer>>() {}, TypeToken.of(String.class));

    // Then return true because reified type List<Integer> was stored when the TypeConverter
    // was created. This allows us to confidently know that the type converter accepts a
    // List<Integer>, even though the Java compiler doesn't know.
    assertThat(typePairFrom(typeConverter)).isEqualTo(typePair);
  }

  @DisplayName("TypeConverter<?,String>().supports( TypePair(String,String) )")
  @Test
  void doesNotSupport1() {

    TypeConverter<?, String> typeConverter =
        new TypeConverter<String, String>() {
          @Override
          public String convert(String source) {
            return "";
          }
        };

    TypePair expected =
        TypePair.create(TypeTokenFactory.listOf(Integer.class), TypeTokenFactory.of(String.class));

    assertThat(typePairFrom(typeConverter)).isNotEqualTo(expected);
  }

  @DisplayName("TypeConverter<?,String>().supports( TypePair(List<Integer>,String) )")
  @Test
  void doesNotSupport2() {

    // Given a type converter with a wildcard type
    // ...making this statement illegal: typeConverter.convert(Collections.emptyList());
    TypeConverter<?, String> typeConverter =
        new TypeConverter<List<?>, String>() {
          @Override
          public String convert(List<?> source) {
            return "";
          }
        };

    // When
    TypePair expected =
        TypePair.create(TypeTokenFactory.listOf(Integer.class), TypeTokenFactory.of(String.class));

    // Then TypeConverter#supports should behave like Java Generics
    assertThat(typePairFrom(typeConverter)).isNotEqualTo(expected);
  }

  @DisplayName("Special case of does not support. See code.")
  @Test
  void doesNotSupport3() {

    // Given a type converter with a wildcard type
    // ...making this statement illegal: typeConverter.convert(Collections.emptyList());
    TypeConverter<?, String> typeConverter =
        new TypeConverter<List<?>, String>() {
          @Override
          public String convert(List<?> source) {
            return "";
          }
        };

    // When
    TypePair expected =
        TypePair.create(TypeTokenFactory.listOf(Integer.class), TypeTokenFactory.of(String.class));

    // Then return false because the TypeConverter stored token type List<?> as its type
    //  when the converter was created. And in this case, we cannot determine exactly
    //  when type of data the list expects, so we cannot claim that the type converter
    //  supports List<Integer>.
    assertThat(typePairFrom(typeConverter)).isNotEqualTo(expected);
  }
}



================================================
FILE: src/test/java/com/radiantlogic/iddm/base/TypePairTest.java
================================================
package com.radiantlogic.iddm.base;

import static org.assertj.core.api.Assertions.assertThat;

import com.google.common.reflect.TypeToken;
import com.radiantlogic.iddm.ResponseEntity;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

class TypePairTest {

  @DisplayName("toString1")
  @Test
  void string1() {
    TypePair typePair = TypePair.create(TypeToken.of(Request.class), new TypeToken<Float>() {});
    String expected = "TypePair(from=com.radiantlogic.iddm.base.Request, to=java.lang.Float)";
    assertThat(typePair).hasToString(expected);
  }

  @DisplayName("toString2")
  @Test
  void string2() {
    TypePair typePair =
        TypePair.create(
            TypeToken.of(LdapRequest.class), new TypeToken<ResponseEntity<String>>() {});
    String expected =
        "TypePair"
            + "(from=com.radiantlogic.iddm.base.LdapRequest, "
            + "to=com.radiantlogic.iddm.ResponseEntity<java.lang.String>)";
    assertThat(typePair).hasToString(expected);
  }

  @DisplayName("Pair(String,String) == Pair(String,String)")
  @Test
  void equal1() {
    assertThat(TypePair.create(String.class, String.class))
        .isEqualTo(TypePair.create(String.class, String.class));
  }

  @DisplayName("Pair(Integer,String) == Pair(Integer,String)")
  @Test
  void equal2() {
    assertThat(TypePair.create(Integer.class, String.class))
        .isEqualTo(TypePair.create(Integer.class, String.class));
  }

  @DisplayName("Pair(List<String>,List<String>) == Pair(List<String>,List<String>)")
  @Test
  void equals3() {
    assertThat(
            TypePair.create(
                TypeTokenFactory.listOf(String.class), TypeTokenFactory.listOf(String.class)))
        .isEqualTo(
            TypePair.create(
                TypeTokenFactory.listOf(String.class), TypeTokenFactory.listOf(String.class)));
  }

  @DisplayName("Pair(Map<String,Integer>,List<String>) == Pair(Map<String,Integer>,List<String>)")
  @Test
  void equals4() {
    assertThat(
            TypePair.create(
                TypeTokenFactory.mapOf(String.class, Integer.class),
                TypeTokenFactory.listOf(String.class)))
        .isEqualTo(
            TypePair.create(
                TypeTokenFactory.mapOf(String.class, Integer.class),
                TypeTokenFactory.listOf(String.class)));
  }

  @DisplayName("Pair(String,Integer>) != Pair(Integer,String)")
  @Test
  void notEqual1() {
    assertThat(TypePair.create(String.class, Integer.class))
        .isNotEqualTo(TypePair.create(Integer.class, String.class));
  }

  @DisplayName("Pair(Object,String) != Pair(String,String)")
  @Test
  void notEqual2() {
    assertThat(TypePair.create(Object.class, String.class))
        .isNotEqualTo(TypePair.create(String.class, String.class));
  }

  @DisplayName("Pair(List<String>,List<String>) != Pair(Map<String,Integer>,List<String>)")
  @Test
  void notEqual3() {
    assertThat(
            TypePair.create(
                TypeTokenFactory.listOf(String.class), TypeTokenFactory.listOf(String.class)))
        .isNotEqualTo(
            TypePair.create(
                TypeTokenFactory.mapOf(String.class, Integer.class),
                TypeTokenFactory.listOf(String.class)));
  }

  @DisplayName("Pair(Map<String,Integer>,List<String>) != Pair(Map<String,String>,List<String>)")
  @Test
  void notEqual4() {
    assertThat(
            TypePair.create(
                TypeTokenFactory.mapOf(String.class, Integer.class),
                TypeTokenFactory.listOf(String.class)))
        .isNotEqualTo(
            TypePair.create(
                TypeTokenFactory.mapOf(String.class, String.class),
                TypeTokenFactory.listOf(String.class)));
  }
}


